"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readline = require("readline");
const lib_1 = require("./lib");
/** Base methods for all methods of communicating information to the user. */
const baseDelegates = {
    error: (error) => {
        console.log(error);
    },
    solved: (answer) => {
        console.log(`The answer is: ${answer.answer}, and I found it in ${answer.attempts} tries.`);
    }
};
const testDelegates = (testAnswer, done) => {
    return Object.assign({}, baseDelegates, { guess: (guess) => {
            // in lieu of user input, just calculate the score on our own using our predetermined test answer,
            // and let the solver know. 
            return new Promise((resolve) => {
                console.log(guess);
                const score = lib_1.calculateScore(testAnswer, guess);
                console.log("response> " + lib_1.printScore(score));
                resolve(score);
            });
        }, solved: (answer) => {
            baseDelegates.solved(answer);
            // verify answer before continuing. 
            if (answer.answer == testAnswer) {
                console.log("Answer is CORRECT.");
                done(answer.attempts);
            }
            else {
                throw new Error("Invalid answer. The answer was: " + testAnswer);
            }
        } });
};
const consoleDelegates = rl => {
    return Object.assign({}, baseDelegates, { guess: (guess) => {
            return new Promise((resolve, _reject) => {
                console.log(guess);
                rl.question("response> ", input => {
                    resolve(lib_1.parseScore(input));
                });
            });
        }, solved: (answer) => {
            baseDelegates.solved(answer);
            rl.close();
        } });
};
/**
 * "Recursive" iteration pattern. Each loop is asynchronous so we need to create a closure
 * and call the next attempt when the current one is finished.
 */
function nextAttempt(left, moves = 0, total = left) {
    // base case, no iterations left. Show average solve length and exunt, stage left.
    if (left == 0) {
        console.log("Average solve length: " + moves / total);
        return;
    }
    // show a running average of the solution length. For my own amusement as I watch the iterations tick. 
    const turn = total - left;
    if (turn != 0) {
        console.log(`Attempt #${turn + 1}, current average moves: ${moves / turn}`);
    }
    // gather the next random config and attempt to solve it. 
    const config = lib_1.getRandomConfig();
    const delegates = testDelegates(config, (a) => {
        nextAttempt(left - 1, moves + a, total);
    });
    lib_1.loop(delegates);
}
if (process.argv.indexOf("auto") != -1) {
    // Auto mode. Specify "auto #" in the args and it will pick them out. It's finicky so don't get fancy. 
    const numbers = process.argv.map(x => parseInt(x, 10)).filter(x => x && x > 0);
    const iterations = numbers.length > 0 ? numbers[0] : 1000;
    console.log(`Performing ${iterations} iterations...`);
    nextAttempt(iterations);
}
else {
    // Input mode. Use readline to gather feedback from the user instead of figuring it out on our own.
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    // only do one loop. If the user wants more, they can run it again. 
    lib_1.loop(consoleDelegates(rl));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxxQ0FBcUM7QUFDckMsK0JBQXlHO0FBRXpHLDZFQUE2RTtBQUM3RSxNQUFNLGFBQWEsR0FBRztJQUNsQixLQUFLLEVBQUUsQ0FBQyxLQUFVLEVBQUUsRUFBRTtRQUNsQixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFDRCxNQUFNLEVBQUUsQ0FBQyxNQUFjLEVBQUUsRUFBRTtRQUN2QixPQUFPLENBQUMsR0FBRyxDQUFDLGtCQUFrQixNQUFNLENBQUMsTUFBTSx1QkFBdUIsTUFBTSxDQUFDLFFBQVEsU0FBUyxDQUFDLENBQUM7SUFDaEcsQ0FBQztDQUNKLENBQUE7QUFVRCxNQUFNLGFBQWEsR0FBa0IsQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLEVBQUU7SUFDdEQsTUFBTSxtQkFDQyxhQUFhLElBQ2hCLEtBQUssRUFBRSxDQUFDLEtBQWEsRUFBRSxFQUFFO1lBQ3JCLGtHQUFrRztZQUNsRyw0QkFBNEI7WUFDNUIsTUFBTSxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQzNCLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ25CLE1BQU0sS0FBSyxHQUFHLG9CQUFjLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNoRCxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksR0FBRyxnQkFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQzlDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNuQixDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsRUFDRCxNQUFNLEVBQUUsQ0FBQyxNQUFjLEVBQUUsRUFBRTtZQUN2QixhQUFhLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTdCLG9DQUFvQztZQUNw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T0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLFVBQVUsZ0JBQWdCLENBQUMsQ0FBQztJQUN0RCxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDNUIsQ0FBQztBQUNELElBQUksQ0FBQyxDQUFDO0lBQ0YsbUdBQW1HO0lBQ25HLE1BQU0sRUFBRSxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUM7UUFDaEMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLO1FBQ3BCLE1BQU0sRUFBRSxPQUFPLENBQUMsTUFBTTtLQUN6QixDQUFDLENBQUM7SUFFSCxvRUFBb0U7SUFDcEUsVUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDL0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHJlYWRsaW5lIGZyb20gJ3JlYWRsaW5lJztcclxuaW1wb3J0IHsgY2FsY3VsYXRlU2NvcmUsIGdldFJhbmRvbUNvbmZpZywgbG9vcCwgcHJpbnRTY29yZSwgQW5zd2VyLCBwYXJzZVNjb3JlLCBEZWxlZ2F0ZXMgfSBmcm9tICcuL2xpYic7XHJcblxyXG4vKiogQmFzZSBtZXRob2RzIGZvciBhbGwgbWV0aG9kcyBvZiBjb21tdW5pY2F0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSB1c2VyLiAqL1xyXG5jb25zdCBiYXNlRGVsZWdhdGVzID0ge1xyXG4gICAgZXJyb3I6IChlcnJvcjogYW55KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgfSxcclxuICAgIHNvbHZlZDogKGFuc3dlcjogQW5zd2VyKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFRoZSBhbnN3ZXIgaXM6ICR7YW5zd2VyLmFuc3dlcn0sIGFuZCBJIGZvdW5kIGl0IGluICR7YW5zd2VyLmF0dGVtcHRzfSB0cmllcy5gKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqIFxyXG4gKiBGb3IgdGVzdGluZywgd2UgY3JlYXRlIGEgZGVsZWdhdGUgdGhhdCdzIHNlYXJjaGluZyBmb3IgYSBzcGVjaWZpYyBhbnN3ZXIgYW5kIHZlcmlmeSB0aGF0IFxyXG4gKiB3ZSd2ZSBmb3VuZCBpdC4gQWRkaXRpb25hbGx5LCB3ZSB0cmFjayB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzIHRoYXQgd2VyZSBtYWRlIGluIG9yZGVyXHJcbiAqIHRvIHRlc3QgdGhlIGl0ZXJhdGl2ZSBhbGdvcml0aG0gb3B0aW1pemF0aW9ucyBJJ3ZlIG1hZGUuXHJcbiAqL1xyXG50eXBlIFRlc3REZWxlZ2F0ZXMgPSB7XHJcbiAgICAodGVzdEFuc3dlcjogc3RyaW5nLCBkb25lOiAoYXR0ZW1wdHM6IG51bWJlcikgPT4gdm9pZCk6IERlbGVnYXRlcztcclxufVxyXG5jb25zdCB0ZXN0RGVsZWdhdGVzOiBUZXN0RGVsZWdhdGVzID0gKHRlc3RBbnN3ZXIsIGRvbmUpID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uYmFzZURlbGVnYXRlcyxcclxuICAgICAgICBndWVzczogKGd1ZXNzOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgLy8gaW4gbGlldSBvZiB1c2VyIGlucHV0LCBqdXN0IGNhbGN1bGF0ZSB0aGUgc2NvcmUgb24gb3VyIG93biB1c2luZyBvdXIgcHJlZGV0ZXJtaW5lZCB0ZXN0IGFuc3dlcixcclxuICAgICAgICAgICAgLy8gYW5kIGxldCB0aGUgc29sdmVyIGtub3cuIFxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGd1ZXNzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gY2FsY3VsYXRlU2NvcmUodGVzdEFuc3dlciwgZ3Vlc3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZXNwb25zZT4gXCIgKyBwcmludFNjb3JlKHNjb3JlKSk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHNjb3JlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzb2x2ZWQ6IChhbnN3ZXI6IEFuc3dlcikgPT4ge1xyXG4gICAgICAgICAgICBiYXNlRGVsZWdhdGVzLnNvbHZlZChhbnN3ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gdmVyaWZ5IGFuc3dlciBiZWZvcmUgY29udGludWluZy4gXHJcbiAgICAgICAgICAgIGlmIChhbnN3ZXIuYW5zd2VyID09IHRlc3RBbnN3ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQW5zd2VyIGlzIENPUlJFQ1QuXCIpO1xyXG4gICAgICAgICAgICAgICAgZG9uZShhbnN3ZXIuYXR0ZW1wdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhbnN3ZXIuIFRoZSBhbnN3ZXIgd2FzOiBcIiArIHRlc3RBbnN3ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKiogXHJcbiAqIEZvciB0aGUgbWVhdCBvZiB0aGUgcHJvZ3JhbSwgd2UgdXNlIHRoZSByZWFkbGluZSBsaWJyYXJ5IHRvIHJlYWQgaW5wdXRzIGZyb20gYSBsaXZlIHVzZXIuXHJcbiAqIFRoZSBwcm9ncmFtIHdhcyBkZXNpZ25lZCBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlIGlucHV0IGlzIGFic3RyYWN0ZWQgYXJvdW5kIGEgcHJvbWlzZSwgYWxsb3dpbmdcclxuICogdXMgdG8gY2FsbCB0aGUgcHJvZ3JhbSB1c2luZyBib3RoIGxpdmUgaW5wdXQsIGFuZCBpdGVyYXRpdmUgdGVzdCBkYXRhIHdpdGhvdXQgYW55IGFsdGVyYXRpb25zLiBcclxuICovXHJcbnR5cGUgQ29uc29sZURlbGVnYXRlcyA9IChybDogcmVhZGxpbmUuUmVhZExpbmUpID0+IERlbGVnYXRlcztcclxuY29uc3QgY29uc29sZURlbGVnYXRlczogQ29uc29sZURlbGVnYXRlcyA9IHJsID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uYmFzZURlbGVnYXRlcyxcclxuICAgICAgICBndWVzczogKGd1ZXNzOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCBfcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhndWVzcyk7XHJcbiAgICAgICAgICAgICAgICBybC5xdWVzdGlvbihcInJlc3BvbnNlPiBcIiwgaW5wdXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocGFyc2VTY29yZShpbnB1dCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc29sdmVkOiAoYW5zd2VyOiBBbnN3ZXIpID0+IHtcclxuICAgICAgICAgICAgYmFzZURlbGVnYXRlcy5zb2x2ZWQoYW5zd2VyKTtcclxuICAgICAgICAgICAgcmwuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiBcclxuICogXCJSZWN1cnNpdmVcIiBpdGVyYXRpb24gcGF0dGVybi4gRWFjaCBsb29wIGlzIGFzeW5jaHJvbm91cyBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGNsb3N1cmVcclxuICogYW5kIGNhbGwgdGhlIG5leHQgYXR0ZW1wdCB3aGVuIHRoZSBjdXJyZW50IG9uZSBpcyBmaW5pc2hlZC4gXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXh0QXR0ZW1wdChsZWZ0OiBudW1iZXIsIG1vdmVzOiBudW1iZXIgPSAwLCB0b3RhbDogbnVtYmVyID0gbGVmdCkge1xyXG4gICAgLy8gYmFzZSBjYXNlLCBubyBpdGVyYXRpb25zIGxlZnQuIFNob3cgYXZlcmFnZSBzb2x2ZSBsZW5ndGggYW5kIGV4dW50LCBzdGFnZSBsZWZ0LlxyXG4gICAgaWYgKGxlZnQgPT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXZlcmFnZSBzb2x2ZSBsZW5ndGg6IFwiICsgbW92ZXMgLyB0b3RhbCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNob3cgYSBydW5uaW5nIGF2ZXJhZ2Ugb2YgdGhlIHNvbHV0aW9uIGxlbmd0aC4gRm9yIG15IG93biBhbXVzZW1lbnQgYXMgSSB3YXRjaCB0aGUgaXRlcmF0aW9ucyB0aWNrLiBcclxuICAgIGNvbnN0IHR1cm4gPSB0b3RhbCAtIGxlZnQ7XHJcbiAgICBpZiAodHVybiAhPSAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYEF0dGVtcHQgIyR7dHVybiArIDF9LCBjdXJyZW50IGF2ZXJhZ2UgbW92ZXM6ICR7bW92ZXMgLyB0dXJufWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdhdGhlciB0aGUgbmV4dCByYW5kb20gY29uZmlnIGFuZCBhdHRlbXB0IHRvIHNvbHZlIGl0LiBcclxuICAgIGNvbnN0IGNvbmZpZyA9IGdldFJhbmRvbUNvbmZpZygpO1xyXG4gICAgY29uc3QgZGVsZWdhdGVzID0gdGVzdERlbGVnYXRlcyhjb25maWcsIChhKSA9PiB7XHJcbiAgICAgICAgbmV4dEF0dGVtcHQobGVmdCAtIDEsIG1vdmVzICsgYSwgdG90YWwpO1xyXG4gICAgfSk7XHJcbiAgICBsb29wKGRlbGVnYXRlcyk7XHJcbn1cclxuXHJcbmlmIChwcm9jZXNzLmFyZ3YuaW5kZXhPZihcImF1dG9cIikgIT0gLTEpIHtcclxuICAgIC8vIEF1dG8gbW9kZS4gU3BlY2lmeSBcImF1dG8gI1wiIGluIHRoZSBhcmdzIGFuZCBpdCB3aWxsIHBpY2sgdGhlbSBvdXQuIEl0J3MgZmluaWNreSBzbyBkb24ndCBnZXQgZmFuY3kuIFxyXG4gICAgY29uc3QgbnVtYmVycyA9IHByb2Nlc3MuYXJndi5tYXAoeCA9PiBwYXJzZUludCh4LCAxMCkpLmZpbHRlcih4ID0+IHggJiYgeCA+IDApO1xyXG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IG51bWJlcnMubGVuZ3RoID4gMCA/IG51bWJlcnNbMF0gOiAxMDAwO1xyXG4gICAgY29uc29sZS5sb2coYFBlcmZvcm1pbmcgJHtpdGVyYXRpb25zfSBpdGVyYXRpb25zLi4uYCk7XHJcbiAgICBuZXh0QXR0ZW1wdChpdGVyYXRpb25zKTtcclxufVxyXG5lbHNlIHtcclxuICAgIC8vIElucHV0IG1vZGUuIFVzZSByZWFkbGluZSB0byBnYXRoZXIgZmVlZGJhY2sgZnJvbSB0aGUgdXNlciBpbnN0ZWFkIG9mIGZpZ3VyaW5nIGl0IG91dCBvbiBvdXIgb3duLlxyXG4gICAgY29uc3QgcmwgPSByZWFkbGluZS5jcmVhdGVJbnRlcmZhY2Uoe1xyXG4gICAgICAgIGlucHV0OiBwcm9jZXNzLnN0ZGluLFxyXG4gICAgICAgIG91dHB1dDogcHJvY2Vzcy5zdGRvdXRcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIG9ubHkgZG8gb25lIGxvb3AuIElmIHRoZSB1c2VyIHdhbnRzIG1vcmUsIHRoZXkgY2FuIHJ1biBpdCBhZ2Fpbi4gXHJcbiAgICBsb29wKGNvbnNvbGVEZWxlZ2F0ZXMocmwpKTtcclxufVxyXG4iXX0=