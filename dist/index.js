"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readline = require("readline");
const lib_1 = require("./lib");
/** Base methods for all methods of communicating information to the user. */
const baseDelegates = {
    error: (error) => {
        console.log(error);
    },
    solved: (answer) => {
        console.log(`The answer is: ${answer.answer}, and I found it in ${answer.attempts} tries.`);
    }
};
const testDelegates = (testAnswer, done) => {
    return Object.assign({}, baseDelegates, { guess: (guess) => {
            // in lieu of user input, just calculate the score on our own using our predetermined test answer,
            // and let the solver know. 
            return new Promise((resolve) => {
                console.log(guess);
                const score = lib_1.calculateScore(testAnswer, guess);
                console.log("response> " + lib_1.printScore(score));
                resolve(score);
            });
        }, solved: (answer) => {
            baseDelegates.solved(answer);
            // verify answer before continuing. 
            if (answer.answer == testAnswer) {
                console.log("Answer is CORRECT.");
                done(answer.attempts);
            }
            else {
                throw new Error("Invalid answer. The answer was: " + testAnswer);
            }
        } });
};
const consoleDelegates = rl => {
    return Object.assign({}, baseDelegates, { guess: (guess) => {
            return new Promise((resolve, _reject) => {
                console.log(guess);
                rl.question("response> ", input => {
                    const score = lib_1.parseScore(input);
                    resolve(score);
                });
            });
        }, solved: (answer) => {
            baseDelegates.solved(answer);
            rl.close();
        } });
};
/**
 * "Recursive" iteration pattern. Each loop is asynchronous so we need to create a closure
 * and call the next attempt when the current one is finished.
 */
function nextAttempt(left, moves = 0, total = left) {
    // base case, no iterations left. Show average solve length and exunt, stage left.
    if (left == 0) {
        console.log("Average solve length: " + moves / total);
        return;
    }
    // show a running average of the solution length. For my own amusement as I watch the iterations tick. 
    const turn = total - left;
    if (turn != 0) {
        console.log(`Attempt #${turn + 1}, current average moves: ${moves / turn}`);
    }
    // gather the next random config and attempt to solve it. 
    const config = lib_1.getRandomConfig();
    const delegates = testDelegates(config, (a) => {
        nextAttempt(left - 1, moves + a, total);
    });
    lib_1.loop(delegates);
}
if (process.argv.indexOf("auto") != -1) {
    // Auto mode. Specify "auto #" in the args and it will pick them out. It's finicky so don't get fancy. 
    const numbers = process.argv.map(x => parseInt(x, 10)).filter(x => x && x > 0);
    const iterations = numbers.length > 0 ? numbers[0] : 1000;
    console.log(`Performing ${iterations} iterations...`);
    nextAttempt(iterations);
}
else {
    // Input mode. Use readline to gather feedback from the user instead of figuring it out on our own.
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    // only do one loop. If the user wants more, they can run it again. 
    lib_1.loop(consoleDelegates(rl));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxxQ0FBcUM7QUFDckMsK0JBQXlHO0FBRXpHLDZFQUE2RTtBQUM3RSxNQUFNLGFBQWEsR0FBRztJQUNsQixLQUFLLEVBQUUsQ0FBQyxLQUFVLEVBQUUsRUFBRTtRQUNsQixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFDRCxNQUFNLEVBQUUsQ0FBQyxNQUFjLEVBQUUsRUFBRTtRQUN2QixPQUFPLENBQUMsR0FBRyxDQUFDLGtCQUFrQixNQUFNLENBQUMsTUFBTSx1QkFBdUIsTUFBTSxDQUFDLFFBQVEsU0FBUyxDQUFDLENBQUM7SUFDaEcsQ0FBQztDQUNKLENBQUE7QUFVRCxNQUFNLGFBQWEsR0FBa0IsQ0FBQyxVQUFVLEVBQUUsSUFBSSxFQUFFLEVBQUU7SUFDdEQsTUFBTSxtQkFDQyxhQUFhLElBQ2hCLEtBQUssRUFBRSxDQUFDLEtBQWEsRUFBRSxFQUFFO1lBQ3JCLGtHQUFrRztZQUNsRyw0QkFBNEI7WUFDNUIsTUFBTSxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQzNCLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ25CLE1BQU0sS0FBSyxHQUFHLG9CQUFjLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNoRCxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksR0FBRyxnQkFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQzlDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNuQixDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsRUFDRCxNQUFNLEVBQUUsQ0FBQyxNQUFjLEVBQUUsRUFBRTtZQUN2QixhQUFhLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRTdCLG9DQUFvQztZQUNw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LENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUMxRCxPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsVUFBVSxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3RELFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUM1QixDQUFDO0FBQ0QsSUFBSSxDQUFDLENBQUM7SUFDRixtR0FBbUc7SUFDbkcsTUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQztRQUNoQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUs7UUFDcEIsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFNO0tBQ3pCLENBQUMsQ0FBQztJQUVILG9FQUFvRTtJQUNwRSxVQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMvQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcmVhZGxpbmUgZnJvbSAncmVhZGxpbmUnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVTY29yZSwgZ2V0UmFuZG9tQ29uZmlnLCBsb29wLCBwcmludFNjb3JlLCBBbnN3ZXIsIHBhcnNlU2NvcmUsIERlbGVnYXRlcyB9IGZyb20gJy4vbGliJztcclxuXHJcbi8qKiBCYXNlIG1ldGhvZHMgZm9yIGFsbCBtZXRob2RzIG9mIGNvbW11bmljYXRpbmcgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIuICovXHJcbmNvbnN0IGJhc2VEZWxlZ2F0ZXMgPSB7XHJcbiAgICBlcnJvcjogKGVycm9yOiBhbnkpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICB9LFxyXG4gICAgc29sdmVkOiAoYW5zd2VyOiBBbnN3ZXIpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgVGhlIGFuc3dlciBpczogJHthbnN3ZXIuYW5zd2VyfSwgYW5kIEkgZm91bmQgaXQgaW4gJHthbnN3ZXIuYXR0ZW1wdHN9IHRyaWVzLmApO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiogXHJcbiAqIEZvciB0ZXN0aW5nLCB3ZSBjcmVhdGUgYSBkZWxlZ2F0ZSB0aGF0J3Mgc2VhcmNoaW5nIGZvciBhIHNwZWNpZmljIGFuc3dlciBhbmQgdmVyaWZ5IHRoYXQgXHJcbiAqIHdlJ3ZlIGZvdW5kIGl0LiBBZGRpdGlvbmFsbHksIHdlIHRyYWNrIHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdGhhdCB3ZXJlIG1hZGUgaW4gb3JkZXJcclxuICogdG8gdGVzdCB0aGUgaXRlcmF0aXZlIGFsZ29yaXRobSBvcHRpbWl6YXRpb25zIEkndmUgbWFkZS5cclxuICovXHJcbnR5cGUgVGVzdERlbGVnYXRlcyA9IHtcclxuICAgICh0ZXN0QW5zd2VyOiBzdHJpbmcsIGRvbmU6IChhdHRlbXB0czogbnVtYmVyKSA9PiB2b2lkKTogRGVsZWdhdGVzO1xyXG59XHJcbmNvbnN0IHRlc3REZWxlZ2F0ZXM6IFRlc3REZWxlZ2F0ZXMgPSAodGVzdEFuc3dlciwgZG9uZSkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5iYXNlRGVsZWdhdGVzLFxyXG4gICAgICAgIGd1ZXNzOiAoZ3Vlc3M6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAvLyBpbiBsaWV1IG9mIHVzZXIgaW5wdXQsIGp1c3QgY2FsY3VsYXRlIHRoZSBzY29yZSBvbiBvdXIgb3duIHVzaW5nIG91ciBwcmVkZXRlcm1pbmVkIHRlc3QgYW5zd2VyLFxyXG4gICAgICAgICAgICAvLyBhbmQgbGV0IHRoZSBzb2x2ZXIga25vdy4gXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZ3Vlc3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSBjYWxjdWxhdGVTY29yZSh0ZXN0QW5zd2VyLCBndWVzcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlc3BvbnNlPiBcIiArIHByaW50U2NvcmUoc2NvcmUpKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoc2NvcmUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNvbHZlZDogKGFuc3dlcjogQW5zd2VyKSA9PiB7XHJcbiAgICAgICAgICAgIGJhc2VEZWxlZ2F0ZXMuc29sdmVkKGFuc3dlcik7XHJcblxyXG4gICAgICAgICAgICAvLyB2ZXJpZnkgYW5zd2VyIGJlZm9yZSBjb250aW51aW5nLiBcclxuICAgICAgICAgICAgaWYgKGFuc3dlci5hbnN3ZXIgPT0gdGVzdEFuc3dlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJBbnN3ZXIgaXMgQ09SUkVDVC5cIik7XHJcbiAgICAgICAgICAgICAgICBkb25lKGFuc3dlci5hdHRlbXB0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFuc3dlci4gVGhlIGFuc3dlciB3YXM6IFwiICsgdGVzdEFuc3dlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiBcclxuICogRm9yIHRoZSBtZWF0IG9mIHRoZSBwcm9ncmFtLCB3ZSB1c2UgdGhlIHJlYWRsaW5lIGxpYnJhcnkgdG8gcmVhZCBpbnB1dHMgZnJvbSBhIGxpdmUgdXNlci5cclxuICogVGhlIHByb2dyYW0gd2FzIGRlc2lnbmVkIGluIHN1Y2ggYSB3YXkgdGhhdCB0aGUgaW5wdXQgaXMgYWJzdHJhY3RlZCBhcm91bmQgYSBwcm9taXNlLCBhbGxvd2luZ1xyXG4gKiB1cyB0byBjYWxsIHRoZSBwcm9ncmFtIHVzaW5nIGJvdGggbGl2ZSBpbnB1dCwgYW5kIGl0ZXJhdGl2ZSB0ZXN0IGRhdGEgd2l0aG91dCBhbnkgYWx0ZXJhdGlvbnMuIFxyXG4gKi9cclxudHlwZSBDb25zb2xlRGVsZWdhdGVzID0gKHJsOiByZWFkbGluZS5SZWFkTGluZSkgPT4gRGVsZWdhdGVzO1xyXG5jb25zdCBjb25zb2xlRGVsZWdhdGVzOiBDb25zb2xlRGVsZWdhdGVzID0gcmwgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5iYXNlRGVsZWdhdGVzLFxyXG4gICAgICAgIGd1ZXNzOiAoZ3Vlc3M6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIF9yZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGd1ZXNzKTtcclxuICAgICAgICAgICAgICAgIHJsLnF1ZXN0aW9uKFwicmVzcG9uc2U+IFwiLCBpbnB1dCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSBwYXJzZVNjb3JlKGlucHV0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNjb3JlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNvbHZlZDogKGFuc3dlcjogQW5zd2VyKSA9PiB7XHJcbiAgICAgICAgICAgIGJhc2VEZWxlZ2F0ZXMuc29sdmVkKGFuc3dlcik7XHJcbiAgICAgICAgICAgIHJsLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKiogXHJcbiAqIFwiUmVjdXJzaXZlXCIgaXRlcmF0aW9uIHBhdHRlcm4uIEVhY2ggbG9vcCBpcyBhc3luY2hyb25vdXMgc28gd2UgbmVlZCB0byBjcmVhdGUgYSBjbG9zdXJlXHJcbiAqIGFuZCBjYWxsIHRoZSBuZXh0IGF0dGVtcHQgd2hlbiB0aGUgY3VycmVudCBvbmUgaXMgZmluaXNoZWQuIFxyXG4gKi9cclxuZnVuY3Rpb24gbmV4dEF0dGVtcHQobGVmdDogbnVtYmVyLCBtb3ZlczogbnVtYmVyID0gMCwgdG90YWw6IG51bWJlciA9IGxlZnQpIHtcclxuICAgIC8vIGJhc2UgY2FzZSwgbm8gaXRlcmF0aW9ucyBsZWZ0LiBTaG93IGF2ZXJhZ2Ugc29sdmUgbGVuZ3RoIGFuZCBleHVudCwgc3RhZ2UgbGVmdC5cclxuICAgIGlmIChsZWZ0ID09IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkF2ZXJhZ2Ugc29sdmUgbGVuZ3RoOiBcIiArIG1vdmVzIC8gdG90YWwpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzaG93IGEgcnVubmluZyBhdmVyYWdlIG9mIHRoZSBzb2x1dGlvbiBsZW5ndGguIEZvciBteSBvd24gYW11c2VtZW50IGFzIEkgd2F0Y2ggdGhlIGl0ZXJhdGlvbnMgdGljay4gXHJcbiAgICBjb25zdCB0dXJuID0gdG90YWwgLSBsZWZ0O1xyXG4gICAgaWYgKHR1cm4gIT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0ICMke3R1cm4gKyAxfSwgY3VycmVudCBhdmVyYWdlIG1vdmVzOiAke21vdmVzIC8gdHVybn1gKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBnYXRoZXIgdGhlIG5leHQgcmFuZG9tIGNvbmZpZyBhbmQgYXR0ZW1wdCB0byBzb2x2ZSBpdC4gXHJcbiAgICBjb25zdCBjb25maWcgPSBnZXRSYW5kb21Db25maWcoKTtcclxuICAgIGNvbnN0IGRlbGVnYXRlcyA9IHRlc3REZWxlZ2F0ZXMoY29uZmlnLCAoYSkgPT4ge1xyXG4gICAgICAgIG5leHRBdHRlbXB0KGxlZnQgLSAxLCBtb3ZlcyArIGEsIHRvdGFsKTtcclxuICAgIH0pO1xyXG4gICAgbG9vcChkZWxlZ2F0ZXMpO1xyXG59XHJcblxyXG5pZiAocHJvY2Vzcy5hcmd2LmluZGV4T2YoXCJhdXRvXCIpICE9IC0xKSB7XHJcbiAgICAvLyBBdXRvIG1vZGUuIFNwZWNpZnkgXCJhdXRvICNcIiBpbiB0aGUgYXJncyBhbmQgaXQgd2lsbCBwaWNrIHRoZW0gb3V0LiBJdCdzIGZpbmlja3kgc28gZG9uJ3QgZ2V0IGZhbmN5LiBcclxuICAgIGNvbnN0IG51bWJlcnMgPSBwcm9jZXNzLmFyZ3YubWFwKHggPT4gcGFyc2VJbnQoeCwgMTApKS5maWx0ZXIoeCA9PiB4ICYmIHggPiAwKTtcclxuICAgIGNvbnN0IGl0ZXJhdGlvbnMgPSBudW1iZXJzLmxlbmd0aCA+IDAgPyBudW1iZXJzWzBdIDogMTAwMDtcclxuICAgIGNvbnNvbGUubG9nKGBQZXJmb3JtaW5nICR7aXRlcmF0aW9uc30gaXRlcmF0aW9ucy4uLmApO1xyXG4gICAgbmV4dEF0dGVtcHQoaXRlcmF0aW9ucyk7XHJcbn1cclxuZWxzZSB7XHJcbiAgICAvLyBJbnB1dCBtb2RlLiBVc2UgcmVhZGxpbmUgdG8gZ2F0aGVyIGZlZWRiYWNrIGZyb20gdGhlIHVzZXIgaW5zdGVhZCBvZiBmaWd1cmluZyBpdCBvdXQgb24gb3VyIG93bi5cclxuICAgIGNvbnN0IHJsID0gcmVhZGxpbmUuY3JlYXRlSW50ZXJmYWNlKHtcclxuICAgICAgICBpbnB1dDogcHJvY2Vzcy5zdGRpbixcclxuICAgICAgICBvdXRwdXQ6IHByb2Nlc3Muc3Rkb3V0XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBvbmx5IGRvIG9uZSBsb29wLiBJZiB0aGUgdXNlciB3YW50cyBtb3JlLCB0aGV5IGNhbiBydW4gaXQgYWdhaW4uIFxyXG4gICAgbG9vcChjb25zb2xlRGVsZWdhdGVzKHJsKSk7XHJcbn1cclxuIl19