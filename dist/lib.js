"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
/** All of the colors valid in the system. */
const colors = ['B', 'G', 'O', 'R', 'Y', 'P'];
/**
 * The maximum length of the combination. This value becomes invalid if it surpasses the length of colors,
 * as it violates the precondition "No two slots can have the same color simultaneously."
 */
const combinationLength = 4;
if (combinationLength > colors.length) {
    throw new Error("An invalid combination length was provided, and it requires that the rules of the system be broken.");
}
/** A precalculated list of all possible score permutations. An optimization for the hot-loop calculateScore() function. */
const allScores = getAllPossibleScores();
/** Perform the main loop of the solver. */
async function loop(delegates, guess, possibilities = initializeSet(), usedCodes = new Set()) {
    if (!guess) {
        // Calculate the first guess. Since no locks can have multiples of the same letter, simply pick the first X
        // colors and use those as the guess. 
        guess = colors.slice(0, combinationLength).join('');
    }
    // Give the user our guess. 
    usedCodes.add(guess);
    const score = await delegates.guess(guess);
    // We got it!
    if (score.black == combinationLength) {
        delegates.solved({ answer: guess, attempts: usedCodes.size });
        return;
    }
    // Just in case. This should never happen if the algorithm is working properly.
    if (possibilities.length <= 1) {
        delegates.error("Something's gone horribly wrong. Sorry, I don't have an answer.");
        return;
    }
    // Pare down the remaining possibilities based on what we've learned from the score. 
    const remaining = parePossibilities(possibilities, guess, score);
    // Come up with another guess and recurse. 
    const nextGuess = findNextGuess(remaining, usedCodes);
    loop(delegates, nextGuess, remaining, usedCodes);
}
exports.loop = loop;
/** Find the next value to present */
function findNextGuess(remaining, usedCodes) {
    // bail out if there's only one option left. That means we know the answer.
    if (remaining.length == 1)
        return remaining[0];
    // We're not actually making a guess. What we're doing is trying to find an answer that has the 
    // potential to eliminate the maximum number of remaining values, so that the size of the pool
    // shrinks by an order of magnitude. We're basically trying to find more information out, rather
    // than make an honest guess. 
    let min = Number.MAX_VALUE;
    let minCombination = "";
    // Turned this iterative to speed it up.
    // Functional looked nicer, but it's a hot O(n^3) loop. Everything counts. 
    for (let possibility of remaining) {
        if (usedCodes.has(possibility))
            continue;
        let max = 0;
        for (let score of allScores) {
            let count = 0;
            for (let guess of remaining) {
                if (scoreEquals(calculateScore(guess, possibility), score))
                    count++;
            }
            max = Math.max(count, max);
        }
        if (max < min) {
            min = max;
            minCombination = possibility;
        }
    }
    return minCombination;
}
/** Determine if the scores are equivalent */
function scoreEquals(left, right) {
    return left.white == right.white && left.black == right.black;
}
exports.scoreEquals = scoreEquals;
/**
 * Removes all possibilities from the remaining list that don't match the score we were given.
 * Since we know that score(x,y) == score(y,x), we can assume that any remaining possibility
 * that doesn't give us the score that was returned with our guess can never be a match.
 */
function parePossibilities(possibilities, guess, score) {
    return possibilities.filter(p => isValidScore(p, guess, score));
}
/** Determines, for the given two combinations, whether the score matches. */
function isValidScore(possibility, guess, score) {
    const c = calculateScore(possibility, guess);
    return scoreEquals(c, score);
}
/** Calculates a score given two combinations. */
const memoizedScores = new Map();
const combinationIndices = _.range(combinationLength);
function calculateScore(guess, possibility) {
    // return cached version if it exists. Hot-loop optimization.
    const memo = memoizedScores.get(guess + possibility);
    if (memo)
        return memo;
    // Get all indices in the strings that don't exactly match. 
    const nonMatchingIndices = combinationIndices.filter(i => guess[i] != possibility[i]);
    // Filter out the exact matches leaving us with arrays of strings that may match, but the positional data
    // is unimportant at this point.
    const g = nonMatchingIndices.map(i => guess[i]);
    const p = nonMatchingIndices.map(i => possibility[i]);
    // Not a fan of iteration here but couldn't think of a simpler way to represent what's going on
    // while also being performant. Iteration it is. Remove items from P if they exist in G.
    // Actually this was more important in the earlier version of the app, when combinations could
    // hold duplicate values. Now that I think about it, this becomes much simpler in the current version.
    // Still, I'm leaving it, because this function works in all cases, whether duplicates are allowed
    // or not. You never know when the future is going to change requirements I guess. Maybe should be 
    // exposed for unit tests in that case but it's a private function, and it works, so... bother.
    let white = 0;
    g.forEach(v => {
        const i = p.indexOf(v);
        if (i != -1) {
            white++;
            p.splice(i, 1);
        }
    });
    // black is the number of items that matched; ie len(guess) - len(nonmatching)
    const score = { white, black: guess.length - nonMatchingIndices.length };
    // Memoize the calculations to speed things up, and set the reverse case too, because 
    // calculateScores(x, y) == calculateScores(y, x).
    memoizedScores.set(guess + possibility, score);
    memoizedScores.set(possibility + guess, score);
    return score;
}
exports.calculateScore = calculateScore;
/**
 * Parses a score in text format into a structure we can use. Doesn't do error-handling.
 * Any invalid string is simply { w: 0, b: 0 } for simplicity. A production app should naturally
 * be more protective.
 */
function parseScore(score) {
    score = score.toLowerCase();
    const w = /(\d)w/g.exec(score);
    const b = /(\d)b/g.exec(score);
    return {
        white: w ? parseInt(w[1]) : 0,
        black: b ? parseInt(b[1]) : 0
    };
}
exports.parseScore = parseScore;
/** Prints a score in AR challenge format, for output purposes. */
function printScore(score) {
    let str = "";
    if (score.white)
        str += score.white + "W";
    if (score.black)
        str += score.black + "B";
    return str;
}
exports.printScore = printScore;
/** Computes a set of all possible combinations */
function initializeSet() {
    return permutateString(_.range(0, colors.length), [], combinationLength);
}
exports.initializeSet = initializeSet;
/** Recursive function that permutates a set of numbers for a set depth. */
function permutateString(set, current, depth) {
    // Use recursion to calculate the string permutations. Start by calculating "1, 2, 3, 4, 5, 6",
    // then recurse down a level, calculating "12, 13, 14, 15, 16" and "21, 23, 24, 25, 26", etc.
    // Continue until the desired depth is reached.
    // base case. No more permutations to explore, convert the "current" array into letters,
    // and join them into a string representing the lock combination. 
    if (depth == 0) {
        return [current.map(x => colors[x]).join('')];
    }
    // More iterations to perform. Recurse down another level. 
    return set
        .filter(i => current.indexOf(i) == -1) // filtering added when the no-duplicates rule was discovered.
        .map(i => permutateString(set, current.concat(i), depth - 1))
        .reduce((p, c) => p.concat(c), []);
}
/** Permutates a list of all possible scores that can exist. */
function getAllPossibleScores() {
    // Scores are of the form xWyB, where the sum of x+y can be at most "combinationlength", and at least 0. 
    // Therefore, iterate through the number 0..combinationlength, and for each sum, calculate
    // the permutations of scores that equal that sum. 
    // For example, getScoresForSum(3) returns: {0,3}, {1,2}, {2,1}, {3,0}.
    // Concatenate all permutations and we have all valid scores. 
    return _.range(0, combinationLength + 1)
        .map(sum => getScoresForSum(sum))
        .reduce((p, c) => p.concat(c), []);
}
/** Permutates a list of all possible scores that have the given sum. */
function getScoresForSum(sum) {
    return _.range(0, sum + 1)
        .map(white => { return { white, black: sum - white }; });
}
/**
 * Gets a random configuration from the set of all possible combinations.
 * There's way faster ways to do this, but it's only for testing so I opted for easiest.
 */
function getRandomConfig() {
    const set = initializeSet();
    return set[_.random(0, set.length - 1, false)];
}
exports.getRandomConfig = getRandomConfig;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2xpYi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDRCQUE0QjtBQXFCNUIsNkNBQTZDO0FBQzdDLE1BQU0sTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUU5Qzs7O0dBR0c7QUFDSCxNQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQztBQUM1QixFQUFFLENBQUMsQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLHFHQUFxRyxDQUFDLENBQUM7QUFDM0gsQ0FBQztBQUVELDJIQUEySDtBQUMzSCxNQUFNLFNBQVMsR0FBRyxvQkFBb0IsRUFBRSxDQUFDO0FBRXpDLDJDQUEyQztBQUNwQyxLQUFLLGVBQWUsU0FBb0IsRUFBRSxLQUFjLEVBQUUsYUFBYSxHQUFHLGFBQWEsRUFBRSxFQUFFLFNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBVTtJQUMzSCxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDVCwyR0FBMkc7UUFDM0csc0NBQXNDO1FBQ3RDLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQsNEJBQTRCO0lBQzVCLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckIsTUFBTSxLQUFLLEdBQUcsTUFBTSxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRTNDLGFBQWE7SUFDYixFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUFJLGlCQUFpQixDQUFDLENBQUMsQ0FBQztRQUNuQyxTQUFTLENBQUMs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QUFDLENBQUM7QUFDbkQsQ0FBQztBQUhELDBDQUdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xyXG5cclxuLyoqIEEgc2NvcmUgdG8gYmUgY2FsY3VsYXRlZCBiZXR3ZWVuIHR3byBsb2NrIGNvbmZpZ3VyYXRpb25zICovXHJcbmV4cG9ydCB0eXBlIFNjb3JlID0geyB3aGl0ZTogbnVtYmVyLCBibGFjazogbnVtYmVyIH07XHJcblxyXG4vKiogYSBmdW5jdGlvbiB0aGF0IHdpbGwgYXN5bmNocm9ub3VzbHkgcmV0dXJuIGEgc2NvcmUgYmFzZWQgb24gYSBnaXZlbiBsb2NrIGd1ZXNzLiAqL1xyXG5leHBvcnQgdHlwZSBHdWVzc2VyID0gKGd1ZXNzOiBzdHJpbmcpID0+IFByb21pc2U8U2NvcmU+O1xyXG5cclxuLyoqIEFuIGFuc3dlciwgcmVwcmVzZW50aW5nIHRoZSBmaW5hbCByZXN1bHQgYW5kIHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gcmVhY2ggdGhhdCByZXN1bHQuICovXHJcbmV4cG9ydCB0eXBlIEFuc3dlciA9IHsgYW5zd2VyOiBzdHJpbmcsIGF0dGVtcHRzOiBudW1iZXIgfTtcclxuXHJcbi8qKiBcclxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgY2FsbGJhY2tzIHRvIGJlIGNhbGxlZCwgZ2l2ZW4gdmFyaW91cyBldmVudHMgdGhhdCBjYW4gaGFwcGVuIGR1cmluZyBjYWxjdWxhdGlvblxyXG4gKiBvZiBhIGd1ZXNzLlxyXG4gKi9cclxuZXhwb3J0IHR5cGUgRGVsZWdhdGVzID0ge1xyXG4gICAgZ3Vlc3M6IEd1ZXNzZXIsXHJcbiAgICBlcnJvcjogKGVycm9yOiBhbnkpID0+IHZvaWQsXHJcbiAgICBzb2x2ZWQ6IChhbnN3ZXI6IEFuc3dlcikgPT4gdm9pZDtcclxufVxyXG5cclxuLyoqIEFsbCBvZiB0aGUgY29sb3JzIHZhbGlkIGluIHRoZSBzeXN0ZW0uICovXHJcbmNvbnN0IGNvbG9ycyA9IFsnQicsICdHJywgJ08nLCAnUicsICdZJywgJ1AnXTtcclxuXHJcbi8qKiBcclxuICogVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBjb21iaW5hdGlvbi4gVGhpcyB2YWx1ZSBiZWNvbWVzIGludmFsaWQgaWYgaXQgc3VycGFzc2VzIHRoZSBsZW5ndGggb2YgY29sb3JzLFxyXG4gKiBhcyBpdCB2aW9sYXRlcyB0aGUgcHJlY29uZGl0aW9uIFwiTm8gdHdvIHNsb3RzIGNhbiBoYXZlIHRoZSBzYW1lIGNvbG9yIHNpbXVsdGFuZW91c2x5LlwiXHJcbiAqL1xyXG5jb25zdCBjb21iaW5hdGlvbkxlbmd0aCA9IDQ7XHJcbmlmIChjb21iaW5hdGlvbkxlbmd0aCA+IGNvbG9ycy5sZW5ndGgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkFuIGludmFsaWQgY29tYmluYXRpb24gbGVuZ3RoIHdhcyBwcm92aWRlZCwgYW5kIGl0IHJlcXVpcmVzIHRoYXQgdGhlIHJ1bGVzIG9mIHRoZSBzeXN0ZW0gYmUgYnJva2VuLlwiKTtcclxufVxyXG5cclxuLyoqIEEgcHJlY2FsY3VsYXRlZCBsaXN0IG9mIGFsbCBwb3NzaWJsZSBzY29yZSBwZXJtdXRhdGlvbnMuIEFuIG9wdGltaXphdGlvbiBmb3IgdGhlIGhvdC1sb29wIGNhbGN1bGF0ZVNjb3JlKCkgZnVuY3Rpb24uICovXHJcbmNvbnN0IGFsbFNjb3JlcyA9IGdldEFsbFBvc3NpYmxlU2NvcmVzKCk7XHJcblxyXG4vKiogUGVyZm9ybSB0aGUgbWFpbiBsb29wIG9mIHRoZSBzb2x2ZXIuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb29wKGRlbGVnYXRlczogRGVsZWdhdGVzLCBndWVzcz86IHN0cmluZywgcG9zc2liaWxpdGllcyA9IGluaXRpYWxpemVTZXQoKSwgdXNlZENvZGVzID0gbmV3IFNldDxzdHJpbmc+KCkpIHtcclxuICAgIGlmICghZ3Vlc3MpIHtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZpcnN0IGd1ZXNzLiBTaW5jZSBubyBsb2NrcyBjYW4gaGF2ZSBtdWx0aXBsZXMgb2YgdGhlIHNhbWUgbGV0dGVyLCBzaW1wbHkgcGljayB0aGUgZmlyc3QgWFxyXG4gICAgICAgIC8vIGNvbG9ycyBhbmQgdXNlIHRob3NlIGFzIHRoZSBndWVzcy4gXHJcbiAgICAgICAgZ3Vlc3MgPSBjb2xvcnMuc2xpY2UoMCwgY29tYmluYXRpb25MZW5ndGgpLmpvaW4oJycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdpdmUgdGhlIHVzZXIgb3VyIGd1ZXNzLiBcclxuICAgIHVzZWRDb2Rlcy5hZGQoZ3Vlc3MpO1xyXG4gICAgY29uc3Qgc2NvcmUgPSBhd2FpdCBkZWxlZ2F0ZXMuZ3Vlc3MoZ3Vlc3MpO1xyXG5cclxuICAgIC8vIFdlIGdvdCBpdCFcclxuICAgIGlmIChzY29yZS5ibGFjayA9PSBjb21iaW5hdGlvbkxlbmd0aCkge1xyXG4gICAgICAgIGRlbGVnYXRlcy5zb2x2ZWQoeyBhbnN3ZXI6IGd1ZXNzLCBhdHRlbXB0czogdXNlZENvZGVzLnNpemUgfSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSnVzdCBpbiBjYXNlLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4gaWYgdGhlIGFsZ29yaXRobSBpcyB3b3JraW5nIHByb3Blcmx5LlxyXG4gICAgaWYgKHBvc3NpYmlsaXRpZXMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICBkZWxlZ2F0ZXMuZXJyb3IoXCJTb21ldGhpbmcncyBnb25lIGhvcnJpYmx5IHdyb25nLiBTb3JyeSwgSSBkb24ndCBoYXZlIGFuIGFuc3dlci5cIik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhcmUgZG93biB0aGUgcmVtYWluaW5nIHBvc3NpYmlsaXRpZXMgYmFzZWQgb24gd2hhdCB3ZSd2ZSBsZWFybmVkIGZyb20gdGhlIHNjb3JlLiBcclxuICAgIGNvbnN0IHJlbWFpbmluZyA9IHBhcmVQb3NzaWJpbGl0aWVzKHBvc3NpYmlsaXRpZXMsIGd1ZXNzLCBzY29yZSk7XHJcblxyXG4gICAgLy8gQ29tZSB1cCB3aXRoIGFub3RoZXIgZ3Vlc3MgYW5kIHJlY3Vyc2UuIFxyXG4gICAgY29uc3QgbmV4dEd1ZXNzID0gZmluZE5leHRHdWVzcyhyZW1haW5pbmcsIHVzZWRDb2Rlcyk7XHJcbiAgICBsb29wKGRlbGVnYXRlcywgbmV4dEd1ZXNzLCByZW1haW5pbmcsIHVzZWRDb2Rlcyk7XHJcbn1cclxuXHJcbi8qKiBGaW5kIHRoZSBuZXh0IHZhbHVlIHRvIHByZXNlbnQgKi9cclxuZnVuY3Rpb24gZmluZE5leHRHdWVzcyhyZW1haW5pbmc6IHN0cmluZ1tdLCB1c2VkQ29kZXM6IFNldDxzdHJpbmc+KSB7XHJcblxyXG4gICAgLy8gYmFpbCBvdXQgaWYgdGhlcmUncyBvbmx5IG9uZSBvcHRpb24gbGVmdC4gVGhhdCBtZWFucyB3ZSBrbm93IHRoZSBhbnN3ZXIuXHJcbiAgICBpZiAocmVtYWluaW5nLmxlbmd0aCA9PSAxKVxyXG4gICAgICAgIHJldHVybiByZW1haW5pbmdbMF07XHJcblxyXG4gICAgLy8gV2UncmUgbm90IGFjdHVhbGx5IG1ha2luZyBhIGd1ZXNzLiBXaGF0IHdlJ3JlIGRvaW5nIGlzIHRyeWluZyB0byBmaW5kIGFuIGFuc3dlciB0aGF0IGhhcyB0aGUgXHJcbiAgICAvLyBwb3RlbnRpYWwgdG8gZWxpbWluYXRlIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZW1haW5pbmcgdmFsdWVzLCBzbyB0aGF0IHRoZSBzaXplIG9mIHRoZSBwb29sXHJcbiAgICAvLyBzaHJpbmtzIGJ5IGFuIG9yZGVyIG9mIG1hZ25pdHVkZS4gV2UncmUgYmFzaWNhbGx5IHRyeWluZyB0byBmaW5kIG1vcmUgaW5mb3JtYXRpb24gb3V0LCByYXRoZXJcclxuICAgIC8vIHRoYW4gbWFrZSBhbiBob25lc3QgZ3Vlc3MuIFxyXG4gICAgbGV0IG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBsZXQgbWluQ29tYmluYXRpb246IHN0cmluZyA9IFwiXCI7XHJcblxyXG4gICAgLy8gVHVybmVkIHRoaXMgaXRlcmF0aXZlIHRvIHNwZWVkIGl0IHVwLlxyXG4gICAgLy8gRnVuY3Rpb25hbCBsb29rZWQgbmljZXIsIGJ1dCBpdCdzIGEgaG90IE8obl4zKSBsb29wLiBFdmVyeXRoaW5nIGNvdW50cy4gXHJcbiAgICBmb3IgKGxldCBwb3NzaWJpbGl0eSBvZiByZW1haW5pbmcpIHtcclxuICAgICAgICBpZiAodXNlZENvZGVzLmhhcyhwb3NzaWJpbGl0eSkpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICBsZXQgbWF4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBzY29yZSBvZiBhbGxTY29yZXMpIHtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgZ3Vlc3Mgb2YgcmVtYWluaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NvcmVFcXVhbHMoY2FsY3VsYXRlU2NvcmUoZ3Vlc3MsIHBvc3NpYmlsaXR5KSwgc2NvcmUpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgoY291bnQsIG1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXggPCBtaW4pIHtcclxuICAgICAgICAgICAgbWluID0gbWF4O1xyXG4gICAgICAgICAgICBtaW5Db21iaW5hdGlvbiA9IHBvc3NpYmlsaXR5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWluQ29tYmluYXRpb247XHJcbn1cclxuXHJcbi8qKiBEZXRlcm1pbmUgaWYgdGhlIHNjb3JlcyBhcmUgZXF1aXZhbGVudCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2NvcmVFcXVhbHMobGVmdDogU2NvcmUsIHJpZ2h0OiBTY29yZSkge1xyXG4gICAgcmV0dXJuIGxlZnQud2hpdGUgPT0gcmlnaHQud2hpdGUgJiYgbGVmdC5ibGFjayA9PSByaWdodC5ibGFjaztcclxufVxyXG5cclxuLyoqIFxyXG4gKiBSZW1vdmVzIGFsbCBwb3NzaWJpbGl0aWVzIGZyb20gdGhlIHJlbWFpbmluZyBsaXN0IHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIHNjb3JlIHdlIHdlcmUgZ2l2ZW4uXHJcbiAqIFNpbmNlIHdlIGtub3cgdGhhdCBzY29yZSh4LHkpID09IHNjb3JlKHkseCksIHdlIGNhbiBhc3N1bWUgdGhhdCBhbnkgcmVtYWluaW5nIHBvc3NpYmlsaXR5XHJcbiAqIHRoYXQgZG9lc24ndCBnaXZlIHVzIHRoZSBzY29yZSB0aGF0IHdhcyByZXR1cm5lZCB3aXRoIG91ciBndWVzcyBjYW4gbmV2ZXIgYmUgYSBtYXRjaC4gXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJlUG9zc2liaWxpdGllcyhwb3NzaWJpbGl0aWVzOiBzdHJpbmdbXSwgZ3Vlc3M6IHN0cmluZywgc2NvcmU6IFNjb3JlKSB7XHJcbiAgICByZXR1cm4gcG9zc2liaWxpdGllcy5maWx0ZXIocCA9PiBpc1ZhbGlkU2NvcmUocCwgZ3Vlc3MsIHNjb3JlKSk7XHJcbn1cclxuXHJcbi8qKiBEZXRlcm1pbmVzLCBmb3IgdGhlIGdpdmVuIHR3byBjb21iaW5hdGlvbnMsIHdoZXRoZXIgdGhlIHNjb3JlIG1hdGNoZXMuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRTY29yZShwb3NzaWJpbGl0eTogc3RyaW5nLCBndWVzczogc3RyaW5nLCBzY29yZTogU2NvcmUpIHtcclxuICAgIGNvbnN0IGMgPSBjYWxjdWxhdGVTY29yZShwb3NzaWJpbGl0eSwgZ3Vlc3MpO1xyXG4gICAgcmV0dXJuIHNjb3JlRXF1YWxzKGMsIHNjb3JlKTtcclxufVxyXG5cclxuLyoqIENhbGN1bGF0ZXMgYSBzY29yZSBnaXZlbiB0d28gY29tYmluYXRpb25zLiAqL1xyXG5jb25zdCBtZW1vaXplZFNjb3JlcyA9IG5ldyBNYXA8c3RyaW5nLCBTY29yZT4oKTtcclxuY29uc3QgY29tYmluYXRpb25JbmRpY2VzID0gXy5yYW5nZShjb21iaW5hdGlvbkxlbmd0aCk7XHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTY29yZShndWVzczogc3RyaW5nLCBwb3NzaWJpbGl0eTogc3RyaW5nKSB7XHJcbiAgICAvLyByZXR1cm4gY2FjaGVkIHZlcnNpb24gaWYgaXQgZXhpc3RzLiBIb3QtbG9vcCBvcHRpbWl6YXRpb24uXHJcbiAgICBjb25zdCBtZW1vID0gbWVtb2l6ZWRTY29yZXMuZ2V0KGd1ZXNzICsgcG9zc2liaWxpdHkpO1xyXG4gICAgaWYgKG1lbW8pXHJcbiAgICAgICAgcmV0dXJuIG1lbW87XHJcblxyXG4gICAgLy8gR2V0IGFsbCBpbmRpY2VzIGluIHRoZSBzdHJpbmdzIHRoYXQgZG9uJ3QgZXhhY3RseSBtYXRjaC4gXHJcbiAgICBjb25zdCBub25NYXRjaGluZ0luZGljZXMgPSBjb21iaW5hdGlvbkluZGljZXMuZmlsdGVyKGkgPT4gZ3Vlc3NbaV0gIT0gcG9zc2liaWxpdHlbaV0pO1xyXG5cclxuICAgIC8vIEZpbHRlciBvdXQgdGhlIGV4YWN0IG1hdGNoZXMgbGVhdmluZyB1cyB3aXRoIGFycmF5cyBvZiBzdHJpbmdzIHRoYXQgbWF5IG1hdGNoLCBidXQgdGhlIHBvc2l0aW9uYWwgZGF0YVxyXG4gICAgLy8gaXMgdW5pbXBvcnRhbnQgYXQgdGhpcyBwb2ludC5cclxuICAgIGNvbnN0IGcgPSBub25NYXRjaGluZ0luZGljZXMubWFwKGkgPT4gZ3Vlc3NbaV0pO1xyXG4gICAgY29uc3QgcCA9IG5vbk1hdGNoaW5nSW5kaWNlcy5tYXAoaSA9PiBwb3NzaWJpbGl0eVtpXSk7XHJcblxyXG4gICAgLy8gTm90IGEgZmFuIG9mIGl0ZXJhdGlvbiBoZXJlIGJ1dCBjb3VsZG4ndCB0aGluayBvZiBhIHNpbXBsZXIgd2F5IHRvIHJlcHJlc2VudCB3aGF0J3MgZ29pbmcgb25cclxuICAgIC8vIHdoaWxlIGFsc28gYmVpbmcgcGVyZm9ybWFudC4gSXRlcmF0aW9uIGl0IGlzLiBSZW1vdmUgaXRlbXMgZnJvbSBQIGlmIHRoZXkgZXhpc3QgaW4gRy5cclxuICAgIC8vIEFjdHVhbGx5IHRoaXMgd2FzIG1vcmUgaW1wb3J0YW50IGluIHRoZSBlYXJsaWVyIHZlcnNpb24gb2YgdGhlIGFwcCwgd2hlbiBjb21iaW5hdGlvbnMgY291bGRcclxuICAgIC8vIGhvbGQgZHVwbGljYXRlIHZhbHVlcy4gTm93IHRoYXQgSSB0aGluayBhYm91dCBpdCwgdGhpcyBiZWNvbWVzIG11Y2ggc2ltcGxlciBpbiB0aGUgY3VycmVudCB2ZXJzaW9uLlxyXG4gICAgLy8gU3RpbGwsIEknbSBsZWF2aW5nIGl0LCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gd29ya3MgaW4gYWxsIGNhc2VzLCB3aGV0aGVyIGR1cGxpY2F0ZXMgYXJlIGFsbG93ZWRcclxuICAgIC8vIG9yIG5vdC4gWW91IG5ldmVyIGtub3cgd2hlbiB0aGUgZnV0dXJlIGlzIGdvaW5nIHRvIGNoYW5nZSByZXF1aXJlbWVudHMgSSBndWVzcy4gTWF5YmUgc2hvdWxkIGJlIFxyXG4gICAgLy8gZXhwb3NlZCBmb3IgdW5pdCB0ZXN0cyBpbiB0aGF0IGNhc2UgYnV0IGl0J3MgYSBwcml2YXRlIGZ1bmN0aW9uLCBhbmQgaXQgd29ya3MsIHNvLi4uIGJvdGhlci5cclxuICAgIGxldCB3aGl0ZSA9IDA7XHJcbiAgICBnLmZvckVhY2godiA9PiB7XHJcbiAgICAgICAgY29uc3QgaSA9IHAuaW5kZXhPZih2KTtcclxuICAgICAgICBpZiAoaSAhPSAtMSkge1xyXG4gICAgICAgICAgICB3aGl0ZSsrO1xyXG4gICAgICAgICAgICBwLnNwbGljZShpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBibGFjayBpcyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgbWF0Y2hlZDsgaWUgbGVuKGd1ZXNzKSAtIGxlbihub25tYXRjaGluZylcclxuICAgIGNvbnN0IHNjb3JlID0geyB3aGl0ZSwgYmxhY2s6IGd1ZXNzLmxlbmd0aCAtIG5vbk1hdGNoaW5nSW5kaWNlcy5sZW5ndGggfTtcclxuXHJcbiAgICAvLyBNZW1vaXplIHRoZSBjYWxjdWxhdGlvbnMgdG8gc3BlZWQgdGhpbmdzIHVwLCBhbmQgc2V0IHRoZSByZXZlcnNlIGNhc2UgdG9vLCBiZWNhdXNlIFxyXG4gICAgLy8gY2FsY3VsYXRlU2NvcmVzKHgsIHkpID09IGNhbGN1bGF0ZVNjb3Jlcyh5LCB4KS5cclxuICAgIG1lbW9pemVkU2NvcmVzLnNldChndWVzcyArIHBvc3NpYmlsaXR5LCBzY29yZSk7XHJcbiAgICBtZW1vaXplZFNjb3Jlcy5zZXQocG9zc2liaWxpdHkgKyBndWVzcywgc2NvcmUpO1xyXG4gICAgcmV0dXJuIHNjb3JlO1xyXG59XHJcblxyXG4vKiogXHJcbiAqIFBhcnNlcyBhIHNjb3JlIGluIHRleHQgZm9ybWF0IGludG8gYSBzdHJ1Y3R1cmUgd2UgY2FuIHVzZS4gRG9lc24ndCBkbyBlcnJvci1oYW5kbGluZy4gXHJcbiAqIEFueSBpbnZhbGlkIHN0cmluZyBpcyBzaW1wbHkgeyB3OiAwLCBiOiAwIH0gZm9yIHNpbXBsaWNpdHkuIEEgcHJvZHVjdGlvbiBhcHAgc2hvdWxkIG5hdHVyYWxseVxyXG4gKiBiZSBtb3JlIHByb3RlY3RpdmUuIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2NvcmUoc2NvcmU6IHN0cmluZyk6IFNjb3JlIHtcclxuICAgIHNjb3JlID0gc2NvcmUudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IHcgPSAvKFxcZCl3L2cuZXhlYyhzY29yZSk7XHJcbiAgICBjb25zdCBiID0gLyhcXGQpYi9nLmV4ZWMoc2NvcmUpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3aGl0ZTogdyA/IHBhcnNlSW50KHdbMV0pIDogMCxcclxuICAgICAgICBibGFjazogYiA/IHBhcnNlSW50KGJbMV0pIDogMFxyXG4gICAgfVxyXG59XHJcblxyXG4vKiogUHJpbnRzIGEgc2NvcmUgaW4gQVIgY2hhbGxlbmdlIGZvcm1hdCwgZm9yIG91dHB1dCBwdXJwb3Nlcy4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByaW50U2NvcmUoc2NvcmU6IFNjb3JlKSB7XHJcbiAgICBsZXQgc3RyID0gXCJcIjtcclxuICAgIGlmIChzY29yZS53aGl0ZSkgc3RyICs9IHNjb3JlLndoaXRlICsgXCJXXCI7XHJcbiAgICBpZiAoc2NvcmUuYmxhY2spIHN0ciArPSBzY29yZS5ibGFjayArIFwiQlwiO1xyXG4gICAgcmV0dXJuIHN0cjtcclxufVxyXG5cclxuLyoqIENvbXB1dGVzIGEgc2V0IG9mIGFsbCBwb3NzaWJsZSBjb21iaW5hdGlvbnMgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVTZXQoKSB7XHJcbiAgICByZXR1cm4gcGVybXV0YXRlU3RyaW5nKF8ucmFuZ2UoMCwgY29sb3JzLmxlbmd0aCksIFtdLCBjb21iaW5hdGlvbkxlbmd0aCk7XHJcbn1cclxuXHJcbi8qKiBSZWN1cnNpdmUgZnVuY3Rpb24gdGhhdCBwZXJtdXRhdGVzIGEgc2V0IG9mIG51bWJlcnMgZm9yIGEgc2V0IGRlcHRoLiAqL1xyXG5mdW5jdGlvbiBwZXJtdXRhdGVTdHJpbmcoc2V0OiBudW1iZXJbXSwgY3VycmVudDogbnVtYmVyW10sIGRlcHRoOiBudW1iZXIpOiBzdHJpbmdbXSB7XHJcbiAgICAvLyBVc2UgcmVjdXJzaW9uIHRvIGNhbGN1bGF0ZSB0aGUgc3RyaW5nIHBlcm11dGF0aW9ucy4gU3RhcnQgYnkgY2FsY3VsYXRpbmcgXCIxLCAyLCAzLCA0LCA1LCA2XCIsXHJcbiAgICAvLyB0aGVuIHJlY3Vyc2UgZG93biBhIGxldmVsLCBjYWxjdWxhdGluZyBcIjEyLCAxMywgMTQsIDE1LCAxNlwiIGFuZCBcIjIxLCAyMywgMjQsIDI1LCAyNlwiLCBldGMuXHJcbiAgICAvLyBDb250aW51ZSB1bnRpbCB0aGUgZGVzaXJlZCBkZXB0aCBpcyByZWFjaGVkLlxyXG5cclxuICAgIC8vIGJhc2UgY2FzZS4gTm8gbW9yZSBwZXJtdXRhdGlvbnMgdG8gZXhwbG9yZSwgY29udmVydCB0aGUgXCJjdXJyZW50XCIgYXJyYXkgaW50byBsZXR0ZXJzLFxyXG4gICAgLy8gYW5kIGpvaW4gdGhlbSBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbG9jayBjb21iaW5hdGlvbi4gXHJcbiAgICBpZiAoZGVwdGggPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBbY3VycmVudC5tYXAoeCA9PiBjb2xvcnNbeF0pLmpvaW4oJycpXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNb3JlIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gUmVjdXJzZSBkb3duIGFub3RoZXIgbGV2ZWwuIFxyXG4gICAgcmV0dXJuIHNldFxyXG4gICAgICAgIC5maWx0ZXIoaSA9PiBjdXJyZW50LmluZGV4T2YoaSkgPT0gLTEpICAgLy8gZmlsdGVyaW5nIGFkZGVkIHdoZW4gdGhlIG5vLWR1cGxpY2F0ZXMgcnVsZSB3YXMgZGlzY292ZXJlZC5cclxuICAgICAgICAubWFwKGkgPT4gcGVybXV0YXRlU3RyaW5nKHNldCwgY3VycmVudC5jb25jYXQoaSksIGRlcHRoIC0gMSkpXHJcbiAgICAgICAgLnJlZHVjZSgocCwgYykgPT4gcC5jb25jYXQoYyksIFtdKTtcclxufVxyXG5cclxuLyoqIFBlcm11dGF0ZXMgYSBsaXN0IG9mIGFsbCBwb3NzaWJsZSBzY29yZXMgdGhhdCBjYW4gZXhpc3QuICovXHJcbmZ1bmN0aW9uIGdldEFsbFBvc3NpYmxlU2NvcmVzKCkge1xyXG4gICAgLy8gU2NvcmVzIGFyZSBvZiB0aGUgZm9ybSB4V3lCLCB3aGVyZSB0aGUgc3VtIG9mIHgreSBjYW4gYmUgYXQgbW9zdCBcImNvbWJpbmF0aW9ubGVuZ3RoXCIsIGFuZCBhdCBsZWFzdCAwLiBcclxuICAgIC8vIFRoZXJlZm9yZSwgaXRlcmF0ZSB0aHJvdWdoIHRoZSBudW1iZXIgMC4uY29tYmluYXRpb25sZW5ndGgsIGFuZCBmb3IgZWFjaCBzdW0sIGNhbGN1bGF0ZVxyXG4gICAgLy8gdGhlIHBlcm11dGF0aW9ucyBvZiBzY29yZXMgdGhhdCBlcXVhbCB0aGF0IHN1bS4gXHJcbiAgICAvLyBGb3IgZXhhbXBsZSwgZ2V0U2NvcmVzRm9yU3VtKDMpIHJldHVybnM6IHswLDN9LCB7MSwyfSwgezIsMX0sIHszLDB9LlxyXG4gICAgLy8gQ29uY2F0ZW5hdGUgYWxsIHBlcm11dGF0aW9ucyBhbmQgd2UgaGF2ZSBhbGwgdmFsaWQgc2NvcmVzLiBcclxuICAgIHJldHVybiBfLnJhbmdlKDAsIGNvbWJpbmF0aW9uTGVuZ3RoICsgMSlcclxuICAgICAgICAubWFwKHN1bSA9PiBnZXRTY29yZXNGb3JTdW0oc3VtKSlcclxuICAgICAgICAucmVkdWNlKChwLCBjKSA9PiBwLmNvbmNhdChjKSwgW10pO1xyXG59XHJcblxyXG4vKiogUGVybXV0YXRlcyBhIGxpc3Qgb2YgYWxsIHBvc3NpYmxlIHNjb3JlcyB0aGF0IGhhdmUgdGhlIGdpdmVuIHN1bS4gKi9cclxuZnVuY3Rpb24gZ2V0U2NvcmVzRm9yU3VtKHN1bTogbnVtYmVyKSB7XHJcbiAgICByZXR1cm4gXy5yYW5nZSgwLCBzdW0gKyAxKVxyXG4gICAgICAgIC5tYXAod2hpdGUgPT4geyByZXR1cm4geyB3aGl0ZSwgYmxhY2s6IHN1bSAtIHdoaXRlIH0gfSk7XHJcbn1cclxuXHJcbi8qKiBcclxuICogR2V0cyBhIHJhbmRvbSBjb25maWd1cmF0aW9uIGZyb20gdGhlIHNldCBvZiBhbGwgcG9zc2libGUgY29tYmluYXRpb25zLiBcclxuICogVGhlcmUncyB3YXkgZmFzdGVyIHdheXMgdG8gZG8gdGhpcywgYnV0IGl0J3Mgb25seSBmb3IgdGVzdGluZyBzbyBJIG9wdGVkIGZvciBlYXNpZXN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmRvbUNvbmZpZygpOiBzdHJpbmcge1xyXG4gICAgY29uc3Qgc2V0ID0gaW5pdGlhbGl6ZVNldCgpO1xyXG4gICAgcmV0dXJuIHNldFtfLnJhbmRvbSgwLCBzZXQubGVuZ3RoIC0gMSwgZmFsc2UpXTtcclxufVxyXG4iXX0=