"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
/** All of the colors valid in the system. */
const colors = ['B', 'G', 'O', 'R', 'Y', 'P'];
/**
 * The maximum length of the combination. This value becomes invalid if it surpasses the length of colors,
 * as it violates the precondition "No two slots can have the same color simultaneously."
 */
const combinationLength = 4;
if (combinationLength > colors.length) {
    throw new Error("An invalid combination length was provided, and it requires that the rules of the system be broken.");
}
/** A precalculated list of all possible score permutations. An optimization for the hot-loop calculateScore() function. */
const allScores = getAllPossibleScores();
/** Perform the main loop of the solver. */
async function loop(delegates, guess, possibilities = getAllCombinations(), usedCodes = new Set()) {
    if (!guess) {
        // Optimal starting moves which minimize the average length of solution:
        // ["OYGP", "OPGY", "RYOG", "YRGO", "PYGO", "PYGR"];
        guess = "PYGO";
    }
    // Give the user our guess. 
    usedCodes.add(guess);
    const score = await delegates.guess(guess);
    // We got it!
    if (score.black == combinationLength) {
        delegates.solved({ answer: guess, attempts: usedCodes.size });
        return;
    }
    // Just in case. This should never happen if the algorithm is working properly.
    if (possibilities.length <= 1) {
        delegates.error("Something's gone horribly wrong. Sorry, I don't have an answer.");
        return;
    }
    // Pare down the remaining possibilities based on what we've learned from the score. 
    const remaining = parePossibilities(possibilities, guess, score);
    // Come up with another guess and recurse. 
    const nextGuess = findNextGuess(remaining, usedCodes);
    loop(delegates, nextGuess, remaining, usedCodes);
}
exports.loop = loop;
/** Find the next value to present */
function findNextGuess(remaining, usedCodes) {
    // bail out if there's only one option left. That means we know the answer.
    if (remaining.length == 1)
        return remaining[0];
    // We're not actually making a guess. What we're doing is trying to find an answer that has the 
    // potential to eliminate the maximum number of remaining values, so that the size of the pool
    // shrinks by an order of magnitude. We're basically trying to find more information out, rather
    // than make an honest guess. 
    let min = Number.MAX_VALUE;
    let minCombination = "";
    // Turned this iterative to speed it up.
    // Functional looked nicer, but it's a hot O(n^3) loop. Everything counts. 
    for (let possibility of remaining) {
        if (usedCodes.has(possibility))
            continue;
        let max = 0;
        for (let score of allScores) {
            let count = 0;
            for (let guess of remaining) {
                if (scoreEquals(calculateScore(guess, possibility), score))
                    count++;
            }
            max = Math.max(count, max);
        }
        if (max < min) {
            min = max;
            minCombination = possibility;
        }
    }
    return minCombination;
}
/** Determine if the scores are equivalent */
function scoreEquals(left, right) {
    return left.white == right.white && left.black == right.black;
}
exports.scoreEquals = scoreEquals;
/**
 * Removes all possibilities from the remaining list that don't match the score we were given.
 * Since we know that score(x,y) == score(y,x), we can assume that any remaining possibility
 * that doesn't give us the score that was returned with our guess can never be a match.
 */
function parePossibilities(possibilities, guess, score) {
    return possibilities.filter(p => isValidScore(p, guess, score));
}
/** Determines, for the given two combinations, whether the score matches. */
function isValidScore(possibility, guess, score) {
    const c = calculateScore(possibility, guess);
    return scoreEquals(c, score);
}
/** Calculates a score given two combinations. */
const memoizedScores = new Map();
const combinationIndices = _.range(combinationLength);
function calculateScore(guess, possibility) {
    // return cached version if it exists. Hot-loop optimization.
    const memo = memoizedScores.get(guess + possibility);
    if (memo)
        return memo;
    // Get all indices in the strings that don't exactly match. 
    const nonMatchingIndices = combinationIndices.filter(i => guess[i] != possibility[i]);
    // Filter out the exact matches leaving us with arrays of strings that may match, but the positional data
    // is unimportant at this point.
    const g = nonMatchingIndices.map(i => guess[i]);
    const p = nonMatchingIndices.map(i => possibility[i]);
    // white is the number of non-matching indices where there exists at least one matching entry in p
    // for every entry in g. If the "No two slots can have the same color simultaneously" rule
    // were not in place, this calculation becomes more complex, because of the following situation:
    // "BBOO" vs "OOBG". This current version would erroneously report the score as 4W, because
    // it would match both B's in the first with the single B in the second. Instead the correct 
    // answer is 3W, as you're supposed to cross out the eliminated items as you run across them.
    let white = g.filter(x => p.indexOf(x) != -1).length;
    // black is the number of items that matched; ie len(guess) - len(nonmatching)
    const score = { white, black: guess.length - nonMatchingIndices.length };
    // Memoize the calculations to speed things up, and set the reverse case too, because 
    // calculateScores(x, y) == calculateScores(y, x).
    memoizedScores.set(guess + possibility, score);
    memoizedScores.set(possibility + guess, score);
    return score;
}
exports.calculateScore = calculateScore;
/**
 * Parses a score in text format into a structure we can use. Doesn't do error-handling.
 * Any invalid string is simply { w: 0, b: 0 } for simplicity. A production app should naturally
 * be more protective.
 */
function parseScore(score) {
    score = score.toLowerCase();
    const w = /(\d)w/g.exec(score);
    const b = /(\d)b/g.exec(score);
    return {
        white: w ? parseInt(w[1]) : 0,
        black: b ? parseInt(b[1]) : 0
    };
}
exports.parseScore = parseScore;
/** Prints a score in AR challenge format, for output purposes. */
function printScore(score) {
    let str = "";
    if (score.white)
        str += score.white + "W";
    if (score.black)
        str += score.black + "B";
    return str;
}
exports.printScore = printScore;
/** Computes a set of all possible combinations */
function getAllCombinations() {
    return permutateString(_.range(0, colors.length), [], combinationLength);
}
exports.getAllCombinations = getAllCombinations;
/** Recursive function that permutates a set of numbers for a set depth. */
function permutateString(set, current, depth) {
    // Use recursion to calculate the string permutations. Start by calculating "1, 2, 3, 4, 5, 6",
    // then recurse down a level, calculating "12, 13, 14, 15, 16" and "21, 23, 24, 25, 26", etc.
    // Continue until the desired depth is reached.
    // base case. No more permutations to explore, convert the "current" array into letters,
    // and join them into a string representing the lock combination. 
    if (depth == 0) {
        return [current.map(x => colors[x]).join('')];
    }
    // More iterations to perform. Recurse down another level. 
    return set
        .filter(i => current.indexOf(i) == -1) // filtering added when the no-duplicates rule was discovered.
        .map(i => permutateString(set, current.concat(i), depth - 1))
        .reduce((p, c) => p.concat(c), []);
}
/** Permutates a list of all possible scores that can exist. */
function getAllPossibleScores() {
    // Scores are of the form xWyB, where the sum of x+y can be at most "combinationlength", and at least 0. 
    // Therefore, iterate through the number 0..combinationlength, and for each sum, calculate
    // the permutations of scores that equal that sum. 
    // For example, getScoresForSum(3) returns: {0,3}, {1,2}, {2,1}, {3,0}.
    // Concatenate all permutations and we have all valid scores. 
    return _.range(0, combinationLength + 1)
        .map(sum => getScoresForSum(sum))
        .reduce((p, c) => p.concat(c), []);
}
/** Permutates a list of all possible scores that have the given sum. */
function getScoresForSum(sum) {
    return _.range(0, sum + 1)
        .map(white => { return { white, black: sum - white }; });
}
/**
 * Gets a random configuration from the set of all possible combinations.
 * There's way faster ways to do this, but it's only for testing so I opted for easiest.
 */
function getRandomConfig() {
    const set = getAllCombinations();
    return set[_.random(0, set.length - 1, false)];
}
exports.getRandomConfig = getRandomConfig;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGliLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2xpYi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDRCQUE0QjtBQXFCNUIsNkNBQTZDO0FBQzdDLE1BQU0sTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUU5Qzs7O0dBR0c7QUFDSCxNQUFNLGlCQUFpQixHQUFHLENBQUMsQ0FBQztBQUM1QixFQUFFLENBQUMsQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLHFHQUFxRyxDQUFDLENBQUM7QUFDM0gsQ0FBQztBQUVELDJIQUEySDtBQUMzSCxNQUFNLFNBQVMsR0FBRyxvQkFBb0IsRUFBRSxDQUFDO0FBRXpDLDJDQUEyQztBQUNwQyxLQUFLLGVBQWUsU0FBb0IsRUFBRSxLQUFjLEVBQUUsYUFBYSxHQUFHLGtCQUFrQixFQUFFLEVBQUUsU0FBUyxHQUFHLElBQUksR0FBRyxFQUFVO0lBQ2hJLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNULHdFQUF3RTtRQUN4RSxvREFBb0Q7UUFDcEQsS0FBSyxHQUFHLE1BQU0sQ0FBQztJQUNuQixDQUFDO0lBRUQsNEJBQTRCO0lBQzVCLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckIsTUFBTSxLQUFLLEdBQUcsTUFBTSxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRTNDLGFBQWE7SUFDYixFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUFJLGlCQUFpQixDQUFDLENBQUMsQ0FBQztRQUNuQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsU0FBUyxDQUFDLElBQUks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R0FBeUc7SUFDekcsMEZBQTBGO0lBQzFGLG1EQUFtRDtJQUNuRCx1RUFBdUU7SUFDdkUsOERBQThEO0lBQzlELE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxpQkFBaUIsR0FBRyxDQUFDLENBQUM7U0FDbkMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2hDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDM0MsQ0FBQztBQUVELHdFQUF3RTtBQUN4RSx5QkFBeUIsR0FBVztJQUNoQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQztTQUNyQixHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsR0FBRyxNQUFNLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsR0FBRyxLQUFLLEVBQUUsQ0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hFLENBQUM7QUFFRDs7O0dBR0c7QUFDSDtJQUNJLE1BQU0sR0FBRyxHQUFHLGtCQUFrQixFQUFFLENBQUM7SUFDakMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ25ELENBQUM7QUFIRCwwQ0FHQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcclxuXHJcbi8qKiBBIHNjb3JlIHRvIGJlIGNhbGN1bGF0ZWQgYmV0d2VlbiB0d28gbG9jayBjb25maWd1cmF0aW9ucyAqL1xyXG5leHBvcnQgdHlwZSBTY29yZSA9IHsgd2hpdGU6IG51bWJlciwgYmxhY2s6IG51bWJlciB9O1xyXG5cclxuLyoqIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGFzeW5jaHJvbm91c2x5IHJldHVybiBhIHNjb3JlIGJhc2VkIG9uIGEgZ2l2ZW4gbG9jayBndWVzcy4gKi9cclxuZXhwb3J0IHR5cGUgR3Vlc3NlciA9IChndWVzczogc3RyaW5nKSA9PiBQcm9taXNlPFNjb3JlPjtcclxuXHJcbi8qKiBBbiBhbnN3ZXIsIHJlcHJlc2VudGluZyB0aGUgZmluYWwgcmVzdWx0IGFuZCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzIHRvIHJlYWNoIHRoYXQgcmVzdWx0LiAqL1xyXG5leHBvcnQgdHlwZSBBbnN3ZXIgPSB7IGFuc3dlcjogc3RyaW5nLCBhdHRlbXB0czogbnVtYmVyIH07XHJcblxyXG4vKiogXHJcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIGNhbGxiYWNrcyB0byBiZSBjYWxsZWQsIGdpdmVuIHZhcmlvdXMgZXZlbnRzIHRoYXQgY2FuIGhhcHBlbiBkdXJpbmcgY2FsY3VsYXRpb25cclxuICogb2YgYSBndWVzcy5cclxuICovXHJcbmV4cG9ydCB0eXBlIERlbGVnYXRlcyA9IHtcclxuICAgIGd1ZXNzOiBHdWVzc2VyLFxyXG4gICAgZXJyb3I6IChlcnJvcjogYW55KSA9PiB2b2lkLFxyXG4gICAgc29sdmVkOiAoYW5zd2VyOiBBbnN3ZXIpID0+IHZvaWQ7XHJcbn1cclxuXHJcbi8qKiBBbGwgb2YgdGhlIGNvbG9ycyB2YWxpZCBpbiB0aGUgc3lzdGVtLiAqL1xyXG5jb25zdCBjb2xvcnMgPSBbJ0InLCAnRycsICdPJywgJ1InLCAnWScsICdQJ107XHJcblxyXG4vKiogXHJcbiAqIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgY29tYmluYXRpb24uIFRoaXMgdmFsdWUgYmVjb21lcyBpbnZhbGlkIGlmIGl0IHN1cnBhc3NlcyB0aGUgbGVuZ3RoIG9mIGNvbG9ycyxcclxuICogYXMgaXQgdmlvbGF0ZXMgdGhlIHByZWNvbmRpdGlvbiBcIk5vIHR3byBzbG90cyBjYW4gaGF2ZSB0aGUgc2FtZSBjb2xvciBzaW11bHRhbmVvdXNseS5cIlxyXG4gKi9cclxuY29uc3QgY29tYmluYXRpb25MZW5ndGggPSA0O1xyXG5pZiAoY29tYmluYXRpb25MZW5ndGggPiBjb2xvcnMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBpbnZhbGlkIGNvbWJpbmF0aW9uIGxlbmd0aCB3YXMgcHJvdmlkZWQsIGFuZCBpdCByZXF1aXJlcyB0aGF0IHRoZSBydWxlcyBvZiB0aGUgc3lzdGVtIGJlIGJyb2tlbi5cIik7XHJcbn1cclxuXHJcbi8qKiBBIHByZWNhbGN1bGF0ZWQgbGlzdCBvZiBhbGwgcG9zc2libGUgc2NvcmUgcGVybXV0YXRpb25zLiBBbiBvcHRpbWl6YXRpb24gZm9yIHRoZSBob3QtbG9vcCBjYWxjdWxhdGVTY29yZSgpIGZ1bmN0aW9uLiAqL1xyXG5jb25zdCBhbGxTY29yZXMgPSBnZXRBbGxQb3NzaWJsZVNjb3JlcygpO1xyXG5cclxuLyoqIFBlcmZvcm0gdGhlIG1haW4gbG9vcCBvZiB0aGUgc29sdmVyLiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9vcChkZWxlZ2F0ZXM6IERlbGVnYXRlcywgZ3Vlc3M/OiBzdHJpbmcsIHBvc3NpYmlsaXRpZXMgPSBnZXRBbGxDb21iaW5hdGlvbnMoKSwgdXNlZENvZGVzID0gbmV3IFNldDxzdHJpbmc+KCkpIHtcclxuICAgIGlmICghZ3Vlc3MpIHtcclxuICAgICAgICAvLyBPcHRpbWFsIHN0YXJ0aW5nIG1vdmVzIHdoaWNoIG1pbmltaXplIHRoZSBhdmVyYWdlIGxlbmd0aCBvZiBzb2x1dGlvbjpcclxuICAgICAgICAvLyBbXCJPWUdQXCIsIFwiT1BHWVwiLCBcIlJZT0dcIiwgXCJZUkdPXCIsIFwiUFlHT1wiLCBcIlBZR1JcIl07XHJcbiAgICAgICAgZ3Vlc3MgPSBcIlBZR09cIjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHaXZlIHRoZSB1c2VyIG91ciBndWVzcy4gXHJcbiAgICB1c2VkQ29kZXMuYWRkKGd1ZXNzKTtcclxuICAgIGNvbnN0IHNjb3JlID0gYXdhaXQgZGVsZWdhdGVzLmd1ZXNzKGd1ZXNzKTtcclxuXHJcbiAgICAvLyBXZSBnb3QgaXQhXHJcbiAgICBpZiAoc2NvcmUuYmxhY2sgPT0gY29tYmluYXRpb25MZW5ndGgpIHtcclxuICAgICAgICBkZWxlZ2F0ZXMuc29sdmVkKHsgYW5zd2VyOiBndWVzcywgYXR0ZW1wdHM6IHVzZWRDb2Rlcy5zaXplIH0pXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEp1c3QgaW4gY2FzZS4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIGlmIHRoZSBhbGdvcml0aG0gaXMgd29ya2luZyBwcm9wZXJseS5cclxuICAgIGlmIChwb3NzaWJpbGl0aWVzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgZGVsZWdhdGVzLmVycm9yKFwiU29tZXRoaW5nJ3MgZ29uZSBob3JyaWJseSB3cm9uZy4gU29ycnksIEkgZG9uJ3QgaGF2ZSBhbiBhbnN3ZXIuXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJlIGRvd24gdGhlIHJlbWFpbmluZyBwb3NzaWJpbGl0aWVzIGJhc2VkIG9uIHdoYXQgd2UndmUgbGVhcm5lZCBmcm9tIHRoZSBzY29yZS4gXHJcbiAgICBjb25zdCByZW1haW5pbmcgPSBwYXJlUG9zc2liaWxpdGllcyhwb3NzaWJpbGl0aWVzLCBndWVzcywgc2NvcmUpO1xyXG5cclxuICAgIC8vIENvbWUgdXAgd2l0aCBhbm90aGVyIGd1ZXNzIGFuZCByZWN1cnNlLiBcclxuICAgIGNvbnN0IG5leHRHdWVzcyA9IGZpbmROZXh0R3Vlc3MocmVtYWluaW5nLCB1c2VkQ29kZXMpO1xyXG4gICAgbG9vcChkZWxlZ2F0ZXMsIG5leHRHdWVzcywgcmVtYWluaW5nLCB1c2VkQ29kZXMpO1xyXG59XHJcblxyXG4vKiogRmluZCB0aGUgbmV4dCB2YWx1ZSB0byBwcmVzZW50ICovXHJcbmZ1bmN0aW9uIGZpbmROZXh0R3Vlc3MocmVtYWluaW5nOiBzdHJpbmdbXSwgdXNlZENvZGVzOiBTZXQ8c3RyaW5nPikge1xyXG5cclxuICAgIC8vIGJhaWwgb3V0IGlmIHRoZXJlJ3Mgb25seSBvbmUgb3B0aW9uIGxlZnQuIFRoYXQgbWVhbnMgd2Uga25vdyB0aGUgYW5zd2VyLlxyXG4gICAgaWYgKHJlbWFpbmluZy5sZW5ndGggPT0gMSlcclxuICAgICAgICByZXR1cm4gcmVtYWluaW5nWzBdO1xyXG5cclxuICAgIC8vIFdlJ3JlIG5vdCBhY3R1YWxseSBtYWtpbmcgYSBndWVzcy4gV2hhdCB3ZSdyZSBkb2luZyBpcyB0cnlpbmcgdG8gZmluZCBhbiBhbnN3ZXIgdGhhdCBoYXMgdGhlIFxyXG4gICAgLy8gcG90ZW50aWFsIHRvIGVsaW1pbmF0ZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmVtYWluaW5nIHZhbHVlcywgc28gdGhhdCB0aGUgc2l6ZSBvZiB0aGUgcG9vbFxyXG4gICAgLy8gc2hyaW5rcyBieSBhbiBvcmRlciBvZiBtYWduaXR1ZGUuIFdlJ3JlIGJhc2ljYWxseSB0cnlpbmcgdG8gZmluZCBtb3JlIGluZm9ybWF0aW9uIG91dCwgcmF0aGVyXHJcbiAgICAvLyB0aGFuIG1ha2UgYW4gaG9uZXN0IGd1ZXNzLiBcclxuICAgIGxldCBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgbGV0IG1pbkNvbWJpbmF0aW9uOiBzdHJpbmcgPSBcIlwiO1xyXG5cclxuICAgIC8vIFR1cm5lZCB0aGlzIGl0ZXJhdGl2ZSB0byBzcGVlZCBpdCB1cC5cclxuICAgIC8vIEZ1bmN0aW9uYWwgbG9va2VkIG5pY2VyLCBidXQgaXQncyBhIGhvdCBPKG5eMykgbG9vcC4gRXZlcnl0aGluZyBjb3VudHMuIFxyXG4gICAgZm9yIChsZXQgcG9zc2liaWxpdHkgb2YgcmVtYWluaW5nKSB7XHJcbiAgICAgICAgaWYgKHVzZWRDb2Rlcy5oYXMocG9zc2liaWxpdHkpKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgbGV0IG1heCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgc2NvcmUgb2YgYWxsU2NvcmVzKSB7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGd1ZXNzIG9mIHJlbWFpbmluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlRXF1YWxzKGNhbGN1bGF0ZVNjb3JlKGd1ZXNzLCBwb3NzaWJpbGl0eSksIHNjb3JlKSlcclxuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KGNvdW50LCBtYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4IDwgbWluKSB7XHJcbiAgICAgICAgICAgIG1pbiA9IG1heDtcclxuICAgICAgICAgICAgbWluQ29tYmluYXRpb24gPSBwb3NzaWJpbGl0eTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1pbkNvbWJpbmF0aW9uO1xyXG59XHJcblxyXG4vKiogRGV0ZXJtaW5lIGlmIHRoZSBzY29yZXMgYXJlIGVxdWl2YWxlbnQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNjb3JlRXF1YWxzKGxlZnQ6IFNjb3JlLCByaWdodDogU2NvcmUpIHtcclxuICAgIHJldHVybiBsZWZ0LndoaXRlID09IHJpZ2h0LndoaXRlICYmIGxlZnQuYmxhY2sgPT0gcmlnaHQuYmxhY2s7XHJcbn1cclxuXHJcbi8qKiBcclxuICogUmVtb3ZlcyBhbGwgcG9zc2liaWxpdGllcyBmcm9tIHRoZSByZW1haW5pbmcgbGlzdCB0aGF0IGRvbid0IG1hdGNoIHRoZSBzY29yZSB3ZSB3ZXJlIGdpdmVuLlxyXG4gKiBTaW5jZSB3ZSBrbm93IHRoYXQgc2NvcmUoeCx5KSA9PSBzY29yZSh5LHgpLCB3ZSBjYW4gYXNzdW1lIHRoYXQgYW55IHJlbWFpbmluZyBwb3NzaWJpbGl0eVxyXG4gKiB0aGF0IGRvZXNuJ3QgZ2l2ZSB1cyB0aGUgc2NvcmUgdGhhdCB3YXMgcmV0dXJuZWQgd2l0aCBvdXIgZ3Vlc3MgY2FuIG5ldmVyIGJlIGEgbWF0Y2guIFxyXG4gKi9cclxuZnVuY3Rpb24gcGFyZVBvc3NpYmlsaXRpZXMocG9zc2liaWxpdGllczogc3RyaW5nW10sIGd1ZXNzOiBzdHJpbmcsIHNjb3JlOiBTY29yZSkge1xyXG4gICAgcmV0dXJuIHBvc3NpYmlsaXRpZXMuZmlsdGVyKHAgPT4gaXNWYWxpZFNjb3JlKHAsIGd1ZXNzLCBzY29yZSkpO1xyXG59XHJcblxyXG4vKiogRGV0ZXJtaW5lcywgZm9yIHRoZSBnaXZlbiB0d28gY29tYmluYXRpb25zLCB3aGV0aGVyIHRoZSBzY29yZSBtYXRjaGVzLiAqL1xyXG5mdW5jdGlvbiBpc1ZhbGlkU2NvcmUocG9zc2liaWxpdHk6IHN0cmluZywgZ3Vlc3M6IHN0cmluZywgc2NvcmU6IFNjb3JlKSB7XHJcbiAgICBjb25zdCBjID0gY2FsY3VsYXRlU2NvcmUocG9zc2liaWxpdHksIGd1ZXNzKTtcclxuICAgIHJldHVybiBzY29yZUVxdWFscyhjLCBzY29yZSk7XHJcbn1cclxuXHJcbi8qKiBDYWxjdWxhdGVzIGEgc2NvcmUgZ2l2ZW4gdHdvIGNvbWJpbmF0aW9ucy4gKi9cclxuY29uc3QgbWVtb2l6ZWRTY29yZXMgPSBuZXcgTWFwPHN0cmluZywgU2NvcmU+KCk7XHJcbmNvbnN0IGNvbWJpbmF0aW9uSW5kaWNlcyA9IF8ucmFuZ2UoY29tYmluYXRpb25MZW5ndGgpO1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU2NvcmUoZ3Vlc3M6IHN0cmluZywgcG9zc2liaWxpdHk6IHN0cmluZykge1xyXG4gICAgLy8gcmV0dXJuIGNhY2hlZCB2ZXJzaW9uIGlmIGl0IGV4aXN0cy4gSG90LWxvb3Agb3B0aW1pemF0aW9uLlxyXG4gICAgY29uc3QgbWVtbyA9IG1lbW9pemVkU2NvcmVzLmdldChndWVzcyArIHBvc3NpYmlsaXR5KTtcclxuICAgIGlmIChtZW1vKVxyXG4gICAgICAgIHJldHVybiBtZW1vO1xyXG5cclxuICAgIC8vIEdldCBhbGwgaW5kaWNlcyBpbiB0aGUgc3RyaW5ncyB0aGF0IGRvbid0IGV4YWN0bHkgbWF0Y2guIFxyXG4gICAgY29uc3Qgbm9uTWF0Y2hpbmdJbmRpY2VzID0gY29tYmluYXRpb25JbmRpY2VzLmZpbHRlcihpID0+IGd1ZXNzW2ldICE9IHBvc3NpYmlsaXR5W2ldKTtcclxuXHJcbiAgICAvLyBGaWx0ZXIgb3V0IHRoZSBleGFjdCBtYXRjaGVzIGxlYXZpbmcgdXMgd2l0aCBhcnJheXMgb2Ygc3RyaW5ncyB0aGF0IG1heSBtYXRjaCwgYnV0IHRoZSBwb3NpdGlvbmFsIGRhdGFcclxuICAgIC8vIGlzIHVuaW1wb3J0YW50IGF0IHRoaXMgcG9pbnQuXHJcbiAgICBjb25zdCBnID0gbm9uTWF0Y2hpbmdJbmRpY2VzLm1hcChpID0+IGd1ZXNzW2ldKTtcclxuICAgIGNvbnN0IHAgPSBub25NYXRjaGluZ0luZGljZXMubWFwKGkgPT4gcG9zc2liaWxpdHlbaV0pO1xyXG5cclxuICAgIC8vIHdoaXRlIGlzIHRoZSBudW1iZXIgb2Ygbm9uLW1hdGNoaW5nIGluZGljZXMgd2hlcmUgdGhlcmUgZXhpc3RzIGF0IGxlYXN0IG9uZSBtYXRjaGluZyBlbnRyeSBpbiBwXHJcbiAgICAvLyBmb3IgZXZlcnkgZW50cnkgaW4gZy4gSWYgdGhlIFwiTm8gdHdvIHNsb3RzIGNhbiBoYXZlIHRoZSBzYW1lIGNvbG9yIHNpbXVsdGFuZW91c2x5XCIgcnVsZVxyXG4gICAgLy8gd2VyZSBub3QgaW4gcGxhY2UsIHRoaXMgY2FsY3VsYXRpb24gYmVjb21lcyBtb3JlIGNvbXBsZXgsIGJlY2F1c2Ugb2YgdGhlIGZvbGxvd2luZyBzaXR1YXRpb246XHJcbiAgICAvLyBcIkJCT09cIiB2cyBcIk9PQkdcIi4gVGhpcyBjdXJyZW50IHZlcnNpb24gd291bGQgZXJyb25lb3VzbHkgcmVwb3J0IHRoZSBzY29yZSBhcyA0VywgYmVjYXVzZVxyXG4gICAgLy8gaXQgd291bGQgbWF0Y2ggYm90aCBCJ3MgaW4gdGhlIGZpcnN0IHdpdGggdGhlIHNpbmdsZSBCIGluIHRoZSBzZWNvbmQuIEluc3RlYWQgdGhlIGNvcnJlY3QgXHJcbiAgICAvLyBhbnN3ZXIgaXMgM1csIGFzIHlvdSdyZSBzdXBwb3NlZCB0byBjcm9zcyBvdXQgdGhlIGVsaW1pbmF0ZWQgaXRlbXMgYXMgeW91IHJ1biBhY3Jvc3MgdGhlbS5cclxuICAgIGxldCB3aGl0ZSA9IGcuZmlsdGVyKHggPT4gcC5pbmRleE9mKHgpICE9IC0xKS5sZW5ndGg7XHJcblxyXG4gICAgLy8gYmxhY2sgaXMgdGhlIG51bWJlciBvZiBpdGVtcyB0aGF0IG1hdGNoZWQ7IGllIGxlbihndWVzcykgLSBsZW4obm9ubWF0Y2hpbmcpXHJcbiAgICBjb25zdCBzY29yZSA9IHsgd2hpdGUsIGJsYWNrOiBndWVzcy5sZW5ndGggLSBub25NYXRjaGluZ0luZGljZXMubGVuZ3RoIH07XHJcblxyXG4gICAgLy8gTWVtb2l6ZSB0aGUgY2FsY3VsYXRpb25zIHRvIHNwZWVkIHRoaW5ncyB1cCwgYW5kIHNldCB0aGUgcmV2ZXJzZSBjYXNlIHRvbywgYmVjYXVzZSBcclxuICAgIC8vIGNhbGN1bGF0ZVNjb3Jlcyh4LCB5KSA9PSBjYWxjdWxhdGVTY29yZXMoeSwgeCkuXHJcbiAgICBtZW1vaXplZFNjb3Jlcy5zZXQoZ3Vlc3MgKyBwb3NzaWJpbGl0eSwgc2NvcmUpO1xyXG4gICAgbWVtb2l6ZWRTY29yZXMuc2V0KHBvc3NpYmlsaXR5ICsgZ3Vlc3MsIHNjb3JlKTtcclxuICAgIHJldHVybiBzY29yZTtcclxufVxyXG5cclxuLyoqIFxyXG4gKiBQYXJzZXMgYSBzY29yZSBpbiB0ZXh0IGZvcm1hdCBpbnRvIGEgc3RydWN0dXJlIHdlIGNhbiB1c2UuIERvZXNuJ3QgZG8gZXJyb3ItaGFuZGxpbmcuIFxyXG4gKiBBbnkgaW52YWxpZCBzdHJpbmcgaXMgc2ltcGx5IHsgdzogMCwgYjogMCB9IGZvciBzaW1wbGljaXR5LiBBIHByb2R1Y3Rpb24gYXBwIHNob3VsZCBuYXR1cmFsbHlcclxuICogYmUgbW9yZSBwcm90ZWN0aXZlLiBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNjb3JlKHNjb3JlOiBzdHJpbmcpOiBTY29yZSB7XHJcbiAgICBzY29yZSA9IHNjb3JlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCB3ID0gLyhcXGQpdy9nLmV4ZWMoc2NvcmUpO1xyXG4gICAgY29uc3QgYiA9IC8oXFxkKWIvZy5leGVjKHNjb3JlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgd2hpdGU6IHcgPyBwYXJzZUludCh3WzFdKSA6IDAsXHJcbiAgICAgICAgYmxhY2s6IGIgPyBwYXJzZUludChiWzFdKSA6IDBcclxuICAgIH1cclxufVxyXG5cclxuLyoqIFByaW50cyBhIHNjb3JlIGluIEFSIGNoYWxsZW5nZSBmb3JtYXQsIGZvciBvdXRwdXQgcHVycG9zZXMuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmludFNjb3JlKHNjb3JlOiBTY29yZSkge1xyXG4gICAgbGV0IHN0ciA9IFwiXCI7XHJcbiAgICBpZiAoc2NvcmUud2hpdGUpIHN0ciArPSBzY29yZS53aGl0ZSArIFwiV1wiO1xyXG4gICAgaWYgKHNjb3JlLmJsYWNrKSBzdHIgKz0gc2NvcmUuYmxhY2sgKyBcIkJcIjtcclxuICAgIHJldHVybiBzdHI7XHJcbn1cclxuXHJcbi8qKiBDb21wdXRlcyBhIHNldCBvZiBhbGwgcG9zc2libGUgY29tYmluYXRpb25zICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxDb21iaW5hdGlvbnMoKSB7XHJcbiAgICByZXR1cm4gcGVybXV0YXRlU3RyaW5nKF8ucmFuZ2UoMCwgY29sb3JzLmxlbmd0aCksIFtdLCBjb21iaW5hdGlvbkxlbmd0aCk7XHJcbn1cclxuXHJcbi8qKiBSZWN1cnNpdmUgZnVuY3Rpb24gdGhhdCBwZXJtdXRhdGVzIGEgc2V0IG9mIG51bWJlcnMgZm9yIGEgc2V0IGRlcHRoLiAqL1xyXG5mdW5jdGlvbiBwZXJtdXRhdGVTdHJpbmcoc2V0OiBudW1iZXJbXSwgY3VycmVudDogbnVtYmVyW10sIGRlcHRoOiBudW1iZXIpOiBzdHJpbmdbXSB7XHJcbiAgICAvLyBVc2UgcmVjdXJzaW9uIHRvIGNhbGN1bGF0ZSB0aGUgc3RyaW5nIHBlcm11dGF0aW9ucy4gU3RhcnQgYnkgY2FsY3VsYXRpbmcgXCIxLCAyLCAzLCA0LCA1LCA2XCIsXHJcbiAgICAvLyB0aGVuIHJlY3Vyc2UgZG93biBhIGxldmVsLCBjYWxjdWxhdGluZyBcIjEyLCAxMywgMTQsIDE1LCAxNlwiIGFuZCBcIjIxLCAyMywgMjQsIDI1LCAyNlwiLCBldGMuXHJcbiAgICAvLyBDb250aW51ZSB1bnRpbCB0aGUgZGVzaXJlZCBkZXB0aCBpcyByZWFjaGVkLlxyXG5cclxuICAgIC8vIGJhc2UgY2FzZS4gTm8gbW9yZSBwZXJtdXRhdGlvbnMgdG8gZXhwbG9yZSwgY29udmVydCB0aGUgXCJjdXJyZW50XCIgYXJyYXkgaW50byBsZXR0ZXJzLFxyXG4gICAgLy8gYW5kIGpvaW4gdGhlbSBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbG9jayBjb21iaW5hdGlvbi4gXHJcbiAgICBpZiAoZGVwdGggPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBbY3VycmVudC5tYXAoeCA9PiBjb2xvcnNbeF0pLmpvaW4oJycpXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNb3JlIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gUmVjdXJzZSBkb3duIGFub3RoZXIgbGV2ZWwuIFxyXG4gICAgcmV0dXJuIHNldFxyXG4gICAgICAgIC5maWx0ZXIoaSA9PiBjdXJyZW50LmluZGV4T2YoaSkgPT0gLTEpICAgLy8gZmlsdGVyaW5nIGFkZGVkIHdoZW4gdGhlIG5vLWR1cGxpY2F0ZXMgcnVsZSB3YXMgZGlzY292ZXJlZC5cclxuICAgICAgICAubWFwKGkgPT4gcGVybXV0YXRlU3RyaW5nKHNldCwgY3VycmVudC5jb25jYXQoaSksIGRlcHRoIC0gMSkpXHJcbiAgICAgICAgLnJlZHVjZSgocCwgYykgPT4gcC5jb25jYXQoYyksIFtdKTtcclxufVxyXG5cclxuLyoqIFBlcm11dGF0ZXMgYSBsaXN0IG9mIGFsbCBwb3NzaWJsZSBzY29yZXMgdGhhdCBjYW4gZXhpc3QuICovXHJcbmZ1bmN0aW9uIGdldEFsbFBvc3NpYmxlU2NvcmVzKCkge1xyXG4gICAgLy8gU2NvcmVzIGFyZSBvZiB0aGUgZm9ybSB4V3lCLCB3aGVyZSB0aGUgc3VtIG9mIHgreSBjYW4gYmUgYXQgbW9zdCBcImNvbWJpbmF0aW9ubGVuZ3RoXCIsIGFuZCBhdCBsZWFzdCAwLiBcclxuICAgIC8vIFRoZXJlZm9yZSwgaXRlcmF0ZSB0aHJvdWdoIHRoZSBudW1iZXIgMC4uY29tYmluYXRpb25sZW5ndGgsIGFuZCBmb3IgZWFjaCBzdW0sIGNhbGN1bGF0ZVxyXG4gICAgLy8gdGhlIHBlcm11dGF0aW9ucyBvZiBzY29yZXMgdGhhdCBlcXVhbCB0aGF0IHN1bS4gXHJcbiAgICAvLyBGb3IgZXhhbXBsZSwgZ2V0U2NvcmVzRm9yU3VtKDMpIHJldHVybnM6IHswLDN9LCB7MSwyfSwgezIsMX0sIHszLDB9LlxyXG4gICAgLy8gQ29uY2F0ZW5hdGUgYWxsIHBlcm11dGF0aW9ucyBhbmQgd2UgaGF2ZSBhbGwgdmFsaWQgc2NvcmVzLiBcclxuICAgIHJldHVybiBfLnJhbmdlKDAsIGNvbWJpbmF0aW9uTGVuZ3RoICsgMSlcclxuICAgICAgICAubWFwKHN1bSA9PiBnZXRTY29yZXNGb3JTdW0oc3VtKSlcclxuICAgICAgICAucmVkdWNlKChwLCBjKSA9PiBwLmNvbmNhdChjKSwgW10pO1xyXG59XHJcblxyXG4vKiogUGVybXV0YXRlcyBhIGxpc3Qgb2YgYWxsIHBvc3NpYmxlIHNjb3JlcyB0aGF0IGhhdmUgdGhlIGdpdmVuIHN1bS4gKi9cclxuZnVuY3Rpb24gZ2V0U2NvcmVzRm9yU3VtKHN1bTogbnVtYmVyKSB7XHJcbiAgICByZXR1cm4gXy5yYW5nZSgwLCBzdW0gKyAxKVxyXG4gICAgICAgIC5tYXAod2hpdGUgPT4geyByZXR1cm4geyB3aGl0ZSwgYmxhY2s6IHN1bSAtIHdoaXRlIH0gfSk7XHJcbn1cclxuXHJcbi8qKiBcclxuICogR2V0cyBhIHJhbmRvbSBjb25maWd1cmF0aW9uIGZyb20gdGhlIHNldCBvZiBhbGwgcG9zc2libGUgY29tYmluYXRpb25zLiBcclxuICogVGhlcmUncyB3YXkgZmFzdGVyIHdheXMgdG8gZG8gdGhpcywgYnV0IGl0J3Mgb25seSBmb3IgdGVzdGluZyBzbyBJIG9wdGVkIGZvciBlYXNpZXN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmRvbUNvbmZpZygpOiBzdHJpbmcge1xyXG4gICAgY29uc3Qgc2V0ID0gZ2V0QWxsQ29tYmluYXRpb25zKCk7XHJcbiAgICByZXR1cm4gc2V0W18ucmFuZG9tKDAsIHNldC5sZW5ndGggLSAxLCBmYWxzZSldO1xyXG59XHJcbiJdfQ==